<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Michael is coding</title><link href="https://michaeliscoding.com/" rel="alternate"></link><link href="https://michaeliscoding.com/feeds/atom.xml" rel="self"></link><id>https://michaeliscoding.com/</id><updated>2022-05-26T00:00:00+02:00</updated><subtitle>Learn to write fast, beautiful and efficient code. Understand programming concepts and technologies. Advance your career by learning how to deal with people.</subtitle><entry><title>Difference between function and method</title><link href="https://michaeliscoding.com/difference-between-function-and-method/" rel="alternate"></link><published>2022-05-26T00:00:00+02:00</published><updated>2022-05-26T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2022-05-26:/difference-between-function-and-method/</id><summary type="html">&lt;p&gt;Functions and methods are similar concepts, but they're not the same. Let's see what the difference between them is.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Difference between function and method" src="https://michaeliscoding.com/images/0025-difference-between-function-and-method.jpg"&gt;&lt;/p&gt;
&lt;p&gt;When reading documentation or programming articles, we often see mentions of functions and methods. While they are similar concepts, they’re not the same. It is essential to understand what the difference is.&lt;/p&gt;
&lt;h2 id="what-is-a-function"&gt;What is a function?&lt;a class="headerlink" href="#what-is-a-function" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A function is simply a block (or chunk) of a code with a name. &lt;/p&gt;
&lt;p&gt;If we want to execute the same code multiple times or from multiple places, we put it into function and then call it by its name.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def my_function():
    print('hello')
    print('how are you?')

my_function()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It might have parameters if we want to change the behaviour of the code in the function from the outside:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def my_function(name):
    print('Hello ' + name)
    print('How are you?')

my_function('John')
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="what-is-a-method"&gt;What is a method?&lt;a class="headerlink" href="#what-is-a-method" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A method is also a block (or chunk) of code with a name, and it can also have parameters. But there is one big difference between function and method:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A method is always associated with a class. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So when we talk about a method we talk about a method of a specific class and instances (objects) of that class.&lt;/p&gt;
&lt;p&gt;Here is  a method &lt;code&gt;my_method&lt;/code&gt; in class &lt;code&gt;MyClass&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:

    def my_method(self):
        print('Hello from instance method')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above method is called the &lt;em&gt;instance method&lt;/em&gt;. In Python, instance methods always have at least one parameter named &lt;code&gt;self&lt;/code&gt;. When we call a method on an object Python will put the object the method is called on into this parameter, so we have access to it from within a method. &lt;/p&gt;
&lt;p&gt;To call method &lt;code&gt;my_method&lt;/code&gt;, we first need to create an object from &lt;em&gt;MyClass&lt;/em&gt;, and only then we can call the method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;obj = MyClass()

obj.my_method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also have &lt;em&gt;static methods&lt;/em&gt; in Python. Static methods are associated with the class but do not need the object (instance) of that class. Hence they don’t have &lt;code&gt;self&lt;/code&gt; parameter.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class MyClass:
    @staticmethod
    def my_static_method():
        print('I am static method')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use a static method, we don’t have to create an object first:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;MyClass.my_static_method()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we can still call it on the objects of that class too:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;obj = MyClass()
obj.my_static_method()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So, the difference between functions and methods is the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Methods are always associated with a class and objects of that class. We call methods on objects or classes.&lt;/li&gt;
&lt;li&gt;Functions are not associated with anything and can be called only by their names.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Programming"></category><category term="python"></category><category term="function"></category><category term="method"></category><category term="class"></category><category term="object"></category></entry><entry><title>What is an iterator in Python</title><link href="https://michaeliscoding.com/what-is-an-iterator-in-python/" rel="alternate"></link><published>2021-10-27T00:00:00+02:00</published><updated>2022-05-12T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-27:/what-is-an-iterator-in-python/</id><summary type="html">&lt;p&gt;The iterator is one of the core objects in Python. Understanding iterators is crucial to mastering Python. We'll look at how iterators work, and we'll also create our own iterators.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="What is an iterator in Python" src="https://michaeliscoding.com/images/0024-what-is-iterator-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We've learned before &lt;a href="https://michaeliscoding.com/what-is-an-iterable-in-python/"&gt;what an iterable is&lt;/a&gt;. It is an object we can iterate over - we can go over its items one by one.&lt;/p&gt;
&lt;p&gt;An &lt;strong&gt;iterator&lt;/strong&gt; is an object that does the actual iteration over an &lt;em&gt;iterable&lt;/em&gt;. It provides iteration, enabling us to iterate over an iterable. &lt;/p&gt;
&lt;p&gt;Python &lt;a href="https://docs.python.org/3/glossary.html#term-iterator"&gt;documentation&lt;/a&gt; says it is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An object representing a stream of data&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Iterator reads data from iterable and returns them one by one. Data might be from a container (list, tuple etc.) or other sources like files, network connections, etc.&lt;/p&gt;
&lt;p&gt;So an iterator is an intermediary between the data source - iterable - and code that needs to iterate over its data.
&lt;img alt="Iterator is is an itermediary between iterable and code that needs to iterate over its data" src="https://michaeliscoding.com/images/0024-iterator-intermediary-iterable-code.png"&gt;&lt;/p&gt;
&lt;h2 id="getting-an-iterator-for-iterable"&gt;Getting an iterator for iterable&lt;a class="headerlink" href="#getting-an-iterator-for-iterable" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We use the &lt;code&gt;iter()&lt;/code&gt; function to get an iterator for iterable. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3]
iter(my_list)
# outputs: &amp;lt;list_iterator object at 0x10bbadc90&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;iter()&lt;/code&gt; function calls the &lt;code&gt;__iter__()&lt;/code&gt; method on the iterable to obtain an iterator. 
Iterable's &lt;code&gt;__iter__()&lt;/code&gt; method is responsible for creating and returning an iterator. &lt;/p&gt;
&lt;p&gt;As we'll see later, the iterator needs access to the iterable to get data from it. So when the &lt;code&gt;__iter__&lt;/code&gt; method creates an iterator, it passes the iterable itself to the iterator.&lt;/p&gt;
&lt;p&gt;(Another option is that iterable has the method &lt;code&gt;__getitem__()&lt;/code&gt;  -  we’ve discussed it in the &lt;a href="https://michaeliscoding.com/what-is-an-iterable-in-python/"&gt;article about &lt;em&gt;iterable&lt;/em&gt;)&lt;/a&gt; 
&lt;img alt="How we get an iterator for an iterable" src="https://michaeliscoding.com/images/0024-getting-iterator-for-iterable.png"&gt;&lt;/p&gt;
&lt;h2 id="getting-data-from-the-iterator"&gt;Getting data from the iterator&lt;a class="headerlink" href="#getting-data-from-the-iterator" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once we have an iterator for our iterable, how do we get data from it? &lt;/p&gt;
&lt;p&gt;We pass the iterator to the &lt;code&gt;next()&lt;/code&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# create our iterable
numbers = [1,2,3]

# we get the iterator
it = iter(numbers)

# we call next() to get item
next(it)
1
next(it)
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;next()&lt;/code&gt; function tells the iterator to give us the next item from the iterable.&lt;/p&gt;
&lt;p&gt;Every time we iterate over an iterable (using &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt;, etc.), behind the scenes, Python uses the &lt;code&gt;next()&lt;/code&gt; function to get items one by one. &lt;/p&gt;
&lt;p&gt;If the object passed to the &lt;code&gt;next()&lt;/code&gt; function is not an iterator, &lt;code&gt;next()&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; next(5)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'int' object is not an iterator
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But how does the &lt;code&gt;next()&lt;/code&gt; know if an object is an iterator and how it gets data from it? &lt;/p&gt;
&lt;h2 id="what-makes-object-an-iterator"&gt;What makes object an iterator?&lt;a class="headerlink" href="#what-makes-object-an-iterator" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;next()&lt;/code&gt; function checks if an object has the &lt;code&gt;__next__()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;If it does, it uses it to get the next item.&lt;/p&gt;
&lt;p&gt;If it does &lt;em&gt;not&lt;/em&gt; then &lt;code&gt;next()&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So, an iterator is an object with the &lt;code&gt;__next__()&lt;/code&gt; method. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;code&gt;__next__()&lt;/code&gt;  method is what makes an object an iterator. It is responsible for returning the next item from the iterable.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;next()&lt;/code&gt; function calls the &lt;code&gt;__next__()&lt;/code&gt; method and returns what it returned. &lt;/p&gt;
&lt;p&gt;&lt;img alt="How next() and __next__() get item from iterable" src="https://michaeliscoding.com/images/0024-iterator-next.png"&gt;
We can also use the  &lt;code&gt;__next__()&lt;/code&gt; method directly:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1,2,3]
it = iter(numbers)
it.__next__()
1
it.__next__()
2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But as with any dunder method, we should not. It’s better to use the &lt;code&gt;next()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;We will write our own iterator with the &lt;code&gt;__next__()&lt;/code&gt; method shortly. &lt;/p&gt;
&lt;p&gt;Now, let's look at what happens if there is no next item in an iterable?&lt;/p&gt;
&lt;h2 id="exhaustion"&gt;Exhaustion&lt;a class="headerlink" href="#exhaustion" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When there is no next item, we say the iterator is exhausted, and the &lt;code&gt;__next__()&lt;/code&gt; method must raise &lt;em&gt;StopIteration&lt;/em&gt; error.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1,2,3]

it = iter(numbers)

it.__next__()
1
it.__next__()
2
it.__next__()
3

# now we call __next__() again and we get an error
it.__next__()
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the &lt;code&gt;__next__()&lt;/code&gt; method raises the &lt;em&gt;StopIteration&lt;/em&gt; error, it needs to continue to do so for subsequent calls. Otherwise, it’s broken.&lt;/p&gt;
&lt;p&gt;Let’s call &lt;code&gt;__next()__&lt;/code&gt; once more:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; it.__next__()
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We should always use the &lt;code&gt;next()&lt;/code&gt; function instead of using the &lt;code&gt;__next__()&lt;/code&gt; method directly. When &lt;code&gt;__next__()&lt;/code&gt; raises &lt;em&gt;StopIteration&lt;/em&gt;, the  &lt;code&gt;next()&lt;/code&gt; function propagates that error.  &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1,2,3]

# get iterator
it = iter(numbers)

next(it)
1
next(it)
2
next(it)
3

next(it)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the iterator is exhausted, it is of no use anymore. We can’t get any more items from iterable using exhausted iterator. &lt;/p&gt;
&lt;p&gt;If we want to iterate over an iterable again, we need to get a new iterator from it using &lt;code&gt;iter()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1,2,3]

# get iterator
it = iter(numbers)
next(it)
1
next(it)
2
next(it)
3
next(it)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
# ^^ we exhausted iterator `it`

# but we can get a new iterator
it2 = iter(numbers)
next(it2)
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Getting a new iterator is not possible for all iterables, though. We’ll explain that bit later.&lt;/p&gt;
&lt;h2 id="how-does-it-all-work-together"&gt;How does it all work together?&lt;a class="headerlink" href="#how-does-it-all-work-together" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So how does all of this come together? &lt;/p&gt;
&lt;p&gt;Every time we iterate over the iterable with a &lt;em&gt;for loop&lt;/em&gt;, Python uses the &lt;code&gt;iter()&lt;/code&gt; function (which uses the &lt;code&gt;__iter__()&lt;/code&gt; method) and the &lt;code&gt;next()&lt;/code&gt; function (which uses the &lt;code&gt;__next__()&lt;/code&gt; method) behind the scenes.&lt;/p&gt;
&lt;p&gt;It works like this: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Python uses the &lt;code&gt;iter()&lt;/code&gt; function to get an iter-ator for an object.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;iter()&lt;/code&gt; function uses the &lt;code&gt;__iter__()&lt;/code&gt; method of the object to get an iterator. If the iterable does not have an &lt;code&gt;__iter__()&lt;/code&gt; method (in which case object is not iter-able) or an object returned from the &lt;code&gt;__iter__()&lt;/code&gt; is not an iterator, it raises &lt;em&gt;TypeError&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Python then passes the iterator to the &lt;code&gt;next()&lt;/code&gt; function. &lt;/li&gt;
&lt;li&gt;The &lt;code&gt;next()&lt;/code&gt; function uses the &lt;code&gt;__next__()&lt;/code&gt; method of the iterator to get the next item.  (The &lt;code&gt;next()&lt;/code&gt; checks that iterator has &lt;code&gt;__next__()&lt;/code&gt; method and  raises &lt;code&gt;TypeError&lt;/code&gt; if it does not,  although this was also checked before by the &lt;code&gt;iter()&lt;/code&gt; function.)&lt;/li&gt;
&lt;li&gt;If the &lt;code&gt;__next__()&lt;/code&gt; method returns some item, it is used in the &lt;em&gt;for loop&lt;/em&gt;, and we go back to step 3 - Python calls &lt;code&gt;next()&lt;/code&gt; again.&lt;/li&gt;
&lt;li&gt;If there is no next item,  the &lt;code&gt;__next__()&lt;/code&gt; method raises &lt;code&gt;StopIteration&lt;/code&gt;, stopping the whole process.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="How for loop in Python uses iter() and next() to iterate over iterable" src="https://michaeliscoding.com/images/0024-python-for-loop-iter-next-explained.png"&gt;&lt;/p&gt;
&lt;p&gt;Here's the code that roughly corresponds to what is happening when we use a &lt;em&gt;for loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# Say we have iterable `numbers` like this
numbers = [1, 2, 3]

# This is what Python does when we use a for loop:

# Python will get iterator for `numbers`
it = iter(numbers)

# It starts a while loop with condition True
# so it will run forever unless it is stopped
while True:
    try:
        # it calls the next method passing it the iterator
        item = next(it) 
        # if it returns an item it uses it
        print(item)
    # otherwise next() raises StopIteration and this is where 
    # it will break the while loop
    except StopIteration:
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's now build our own iterator and iterable from scratch.&lt;/p&gt;
&lt;h2 id="building-iterator"&gt;Building iterator&lt;a class="headerlink" href="#building-iterator" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Let's create a simple class &lt;code&gt;Bistro&lt;/code&gt; with three fields, &lt;code&gt;waitress&lt;/code&gt;, &lt;code&gt;chef&lt;/code&gt; and &lt;code&gt;barman&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Bistro:
    def __init__(self, waitress, chef, barman):
        self.waitress = waitress
        self.chef = chef
        self.barman = barman
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we know how our class looks, we can create an iterator for it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class BistroIterator:
    def __init__(self, bistro):
        self.bistro = bistro
        self.next_item = 'waitress'

    def __next__(self):
        if self.next_item == 'waitress':
            self.next_item = 'chef'
            return self.bistro.waitress
        elif self.next_item == 'chef':
            self.next_item = 'barman'
            return self.bistro.chef
        elif self.next_item == 'barman':
            self.next_item = None
            return self.bistro.barman
        else:
            raise StopIteration

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our &lt;em&gt;BistroIterator&lt;/em&gt; needs a &lt;em&gt;Bistro&lt;/em&gt; object for which it provides iteration capability so that it can access its data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When we create our iterator, it stores the &lt;em&gt;Bistro&lt;/em&gt; object into field &lt;code&gt;bistro&lt;/code&gt; and sets which field it will return when it's asked for the next item - we chose to return field &lt;code&gt;waitress&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When the &lt;code&gt;__next__()&lt;/code&gt; method is called, it checks the &lt;code&gt;next_item&lt;/code&gt; field to know what to return.&lt;/li&gt;
&lt;li&gt;If the &lt;code&gt;next_item&lt;/code&gt; field contains the value &lt;code&gt;waitress&lt;/code&gt;, it sets the &lt;code&gt;next_item&lt;/code&gt; to be &lt;code&gt;'chef'&lt;/code&gt; and returns the &lt;code&gt;waitress&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;If it contains the value &lt;code&gt;chef&lt;/code&gt;, it sets the &lt;code&gt;next_item&lt;/code&gt; to &lt;code&gt;'barman'&lt;/code&gt; and returns the &lt;code&gt;chef&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;If it contains the value &lt;code&gt;barman&lt;/code&gt;, it sets the &lt;code&gt;next_item&lt;/code&gt; to None and returns the&lt;code&gt;barman&lt;/code&gt; field.&lt;/li&gt;
&lt;li&gt;If the &lt;code&gt;next_item&lt;/code&gt; is neither of those, it raises a &lt;em&gt;StopIteration&lt;/em&gt; exception.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now we need to update our &lt;em&gt;Bistro&lt;/em&gt; class with the &lt;code&gt;__iter__()&lt;/code&gt; method in which we create a &lt;em&gt;BistroIterator&lt;/em&gt; object, passing itself as a parameter and returning it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class BistroIterator:
    def __init__(self, bistro):
        self.next_item = 'waitress'
        self.bistro = bistro

    def __iter__(self):
        return PersonIterator(self)

    # rest of class as before
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our &lt;em&gt;Bistro&lt;/em&gt; class has become iterable, and we can use a &lt;em&gt;for loop&lt;/em&gt; to iterate over its values:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;our_bistro = Bistro('Mary', 'John', 'Alvin')
for item in our_bistro:
    print(item)

# outputs:
# Mary
# John
# Alvin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that is the iterator's job: Take data from iterable and return them from the &lt;code&gt;__next__()&lt;/code&gt; method one by one.&lt;/p&gt;
&lt;p&gt;Usually, it is not very useful to iterate over objects like &lt;em&gt;Bistro&lt;/em&gt;, but it proves that we can make iterable out of almost any object.&lt;/p&gt;
&lt;h2 id="iterator-is-almost-always-iterable-iterable-can-be-an-iterator"&gt;Iterator is (almost always) iterable  &amp;amp; iterable can be an iterator&lt;a class="headerlink" href="#iterator-is-almost-always-iterable-iterable-can-be-an-iterator" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We said before that iterator is an object that has the &lt;code&gt;__next__()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;But...&lt;/p&gt;
&lt;h3 id="iterator-protocol"&gt;Iterator protocol&lt;a class="headerlink" href="#iterator-protocol" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Python &lt;a href="https://docs.python.org/3/library/stdtypes.html#iterator-types"&gt;documentation&lt;/a&gt; says that iterator is also required to have the &lt;code&gt;__iter__()&lt;/code&gt; method in addition to the &lt;code&gt;__next__()&lt;/code&gt; method to conform to the &lt;em&gt;iterator protocol&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;However, an iterator without &lt;code&gt;__iter__()&lt;/code&gt; will still work because what makes the iterator work is the &lt;code&gt;__next__()&lt;/code&gt; method - as we've seen before. Our &lt;em&gt;BistroIterator&lt;/em&gt; has no &lt;code&gt;__iter__()&lt;/code&gt; method, but it still works.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So iterator does not have to conform to the &lt;em&gt;iterator protocol&lt;/em&gt; to work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When an iterator does have the &lt;code&gt;__iter__()&lt;/code&gt; method, it must return the iterator object &lt;a href="https://docs.python.org/3/library/stdtypes.html#iterator.__iter__"&gt;itself&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class SomeIterator:
    def __iter__(self):
         return self

    def __next__(self):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, most iterators do have the &lt;code&gt;__iter__()&lt;/code&gt; method. &lt;/p&gt;
&lt;p&gt;Why?&lt;/p&gt;
&lt;h3 id="iterator-as-iterable"&gt;Iterator as iterable&lt;a class="headerlink" href="#iterator-as-iterable" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We learned before that if an object has the &lt;code&gt;__iter__()&lt;/code&gt; method, it is iterable. &lt;/p&gt;
&lt;p&gt;So if an &lt;em&gt;iterator&lt;/em&gt; has it, then it's also &lt;em&gt;iterable&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;And that means we can use iterator with &lt;code&gt;for loop&lt;/code&gt; and &lt;code&gt;in&lt;/code&gt; expression and functions that expect iterable.&lt;/p&gt;
&lt;p&gt;Let's try with a &lt;em&gt;for loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3]

# get iterator
it = iter(numbers)

# notice below we use iterator `it` not `numbers`
for item in it:
    print(item)

# outputs
# 1
# 2
# 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works because the &lt;code&gt;for&lt;/code&gt; loop uses the &lt;code&gt;iter()&lt;/code&gt; function to get an iterator for an iterable. Here we gave it an iterator. But the iterator for the list is also iterable - it has the &lt;code&gt;__iter__()&lt;/code&gt; method, which returns self. So the &lt;em&gt;for loop&lt;/em&gt; will use the same iterator as if we looped over &lt;code&gt;numbers&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can check that list's iterator returns &lt;code&gt;self&lt;/code&gt; when we ask for its iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3]

# get iterator
it = iter(numbers)

it
# outputs:
# &amp;lt;list_iterator object at 0x10633f5b0&amp;gt;

# get iterator from iterator
it2 = iter(it)
it2
# outputs:
# &amp;lt;list_iterator object at 0x10633f5b0&amp;gt;

it == it2
# outputs:
# True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So when we give the &lt;em&gt;for loop&lt;/em&gt; an iterator, and it asks for its iterator, it will return itself. Then it proceeds by calling &lt;code&gt;next()&lt;/code&gt; until it raises &lt;em&gt;StopIteration&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;It would not be possible if the iterator had no &lt;code&gt;__iter___ ()&lt;/code&gt; method. If we try the above with our &lt;em&gt;BistroIterator&lt;/em&gt; which doesn't have &lt;code&gt;__iter__()&lt;/code&gt;, we'll get an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;our_bistro = Bistro('Mary', 'John', 'Alvin')
it = iter(our_bistro)

for item in it:
    print(item)

# outputs:
# Traceback (most recent call last):
#   File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
# TypeError: 'PersonIterator' object is not iterable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we add the &lt;code&gt;__iter__()&lt;/code&gt; method, it will work:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class BistroIterator:
    def __init__(self, bistro):
        self.next_item = 'waitress'
        self.bistro = bistro

    def __next__(self):
        if self.next_item == 'waitress':
            self.next_item = 'chef'
            return self.bistro.waitress
        elif self.next_item == 'chef':
            self.next_item = 'barman'
            return self.bistro.chef
        elif self.next_item == 'chef':
            self.next_item = None
            return self.bistro.barman
        else:
            raise StopIteration

    def __iter__(self):
        return self


our_bistro = Bistro('Mary', 'John', 'Alvin')
it = iter(our_bistro)

for item in it:
    print(item)

# outputs:
# Mary
# John
# Alvin
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="not-all-iterables-are-the-same"&gt;Not all iterables are the same&lt;a class="headerlink" href="#not-all-iterables-are-the-same" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Although we can use iterators with the &lt;code&gt;__iter__()&lt;/code&gt; method where iterable is expected, we need to be aware of exhaustion.&lt;/p&gt;
&lt;p&gt;Once an iterator is exhausted, we can't use it anymore to get data from it.&lt;/p&gt;
&lt;p&gt;We said in the &lt;a href="#"&gt;Exhaustion section&lt;/a&gt; that if we want to iterate over iterable multiple times, we could get a new iterator for each iteration.&lt;/p&gt;
&lt;p&gt;But, an iterator that is also iterable will not give us a new iterator when we ask for it because its &lt;code&gt;__iter__()&lt;/code&gt; method returns itself. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3]

it = iter(numbers)
for item in it:
    print(item)
# outputs:
# 1
# 2
# 3

# Now `it` is exhausted.
# But `it` is also an iterable so 
# let's get an iterator from it using `iter()`

it2_from_it = iter(it)

for item in it2_from_it:
    print(item)

# Doesn't outputs anything as `it` and `it2_from_it` 
# are the same object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So a function or other code that expects an iterable  must not assume it will be able to iterate over the iterable more than once.
If the iterable is also iterator it will be exhausted after the first iteration. For further iterations, that code or function will not get any items from the iterable (which is also iterator), which might break it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can iterate only once over iterables whose &lt;code&gt;__iter__()&lt;/code&gt; method always returns the same iterator. They're often iterators themselves.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="different-kinds-of-iterables"&gt;Different kinds of iterables&lt;a class="headerlink" href="#different-kinds-of-iterables" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We've seen that some iterables will return a new iterator each time we ask for it. But others will not.&lt;/p&gt;
&lt;p&gt;Which iterables return a new iterator every time?&lt;/p&gt;
&lt;p&gt;When iterable and iterator are separate objects, iterable will return a new iterator each time we ask for it.&lt;/p&gt;
&lt;p&gt;Our iterable &lt;em&gt;Bistro&lt;/em&gt; is a good example. It creates and returns a new &lt;em&gt;BistroIterator&lt;/em&gt; object every time we ask it for an iterator. So we can iterate over &lt;code&gt;our_bistro&lt;/code&gt; many times.&lt;/p&gt;
&lt;p&gt;Another example is all container objects like list, tuple dict, etc. &lt;/p&gt;
&lt;p&gt;Each time we pass them to the &lt;code&gt;iter()&lt;/code&gt; function (or call their &lt;code&gt;__iter__()&lt;/code&gt; method), they produce a new iterator.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1,2,3]
# get iterator
it = iter(numbers)
next(it)
1
next(it)
2
next(it)
3
next(it)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
StopIteration
# we exhausted iterator `it`

# but we can get a new iterator
it2 = iter(numbers)
next(it2)
1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is because, same as our &lt;em&gt;Bistro&lt;/em&gt; object, they're separate objects from their iterators. They hold data and create an iterator - they have the &lt;code&gt;__iter__()&lt;/code&gt; method. But the iterator is a different object, and only the iterator has the &lt;code&gt;__next__()&lt;/code&gt; method. They don't.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Which iterables return the same iterator every time?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;When an object is both iterable and iterator (has both &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;__next__()&lt;/code&gt; methods), it will return the same iterator - &lt;em&gt;self&lt;/em&gt; - each time we ask for it.&lt;/p&gt;
&lt;p&gt;Usually, it is so when an object doesn't store data we want to iterate over.&lt;/p&gt;
&lt;p&gt;One example is the iterator object with the &lt;code&gt;__iter__()&lt;/code&gt; method. For example, the list iterator we've seen before. It doesn't have any data by itself. It needs another object - iterable (list) - to read data from. It is an iterator for another object, so it just returns itself when asked for its iterator. It doesn't create another iterator as it is an iterator.&lt;/p&gt;
&lt;p&gt;But there are other objects which are both iterable and iterator. They have &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;__next__()&lt;/code&gt; but are not merely iterator for another iterable. &lt;/p&gt;
&lt;p&gt;These objects still don't store any data, but they are doing the work to get data from somewhere. 
For example, Python's file object (_io.TextIOWrapper).
It doesn't contain any data. Those are in a file. But it has the &lt;code&gt;__iter__()&lt;/code&gt; method as well as the &lt;code&gt;__next__()&lt;/code&gt; method. It's not an iterator for another iterable. It is a standalone object that deals with the file to get data, handles file closing, etc.
But when asked for an iterator, it will just return itself.  &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can iterate only once over objects that are both iterator and iterable.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some objects are only iterables. &lt;/li&gt;
&lt;li&gt;Some objects are only iterators, but most iterators are also iterables (even though they are iterators for other iterable). &lt;/li&gt;
&lt;li&gt;And some objects are both iterable and iterator (without being iterator for other iterable ).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can often use iterable and iterator interchangeably. But only when we understand how it works, we can properly decide what to use and how to use it and avoid surprises.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Iterator is an object that provides iteration for iterable.&lt;/li&gt;
&lt;li&gt;We get iterator from iterable using &lt;code&gt;iter()&lt;/code&gt; function which calls &lt;code&gt;__iter__()&lt;/code&gt; method on iterable.&lt;/li&gt;
&lt;li&gt;We get an item from the iterator by passing it to the &lt;code&gt;next()&lt;/code&gt; function. &lt;/li&gt;
&lt;li&gt;&lt;code&gt;next()&lt;/code&gt; function uses &lt;code&gt;__next__()&lt;/code&gt; method of iterator to get the next item in iterable. Iterator has knowledge of and access to iterable.&lt;/li&gt;
&lt;li&gt;Iterator is the object with &lt;code&gt;__next__()&lt;/code&gt; method. &lt;/li&gt;
&lt;li&gt;When there are no more items in iterable, then the iterator is exhausted; in this case, its &lt;code&gt;__next__()&lt;/code&gt; method must raise &lt;em&gt;StopIteration&lt;/em&gt;.  &lt;/li&gt;
&lt;li&gt;&lt;em&gt;for loop&lt;/em&gt; uses &lt;code&gt;iter()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; functions to iterate over the iterable.&lt;/li&gt;
&lt;li&gt;The iterator protocol requires the iterator to have the &lt;code&gt;__iter__()&lt;/code&gt; method, but it will work without it anyway.&lt;/li&gt;
&lt;li&gt;Most iterators have it, though, as it makes iterator an iterable, enabling us to use it in places where iterable is expected. &lt;/li&gt;
&lt;li&gt;Iterator and iterable can be separate objects.&lt;/li&gt;
&lt;li&gt;When they're separate objects, we can get a new iterator for iterable when the current iterator is exhausted.&lt;/li&gt;
&lt;li&gt;But they can also be one object which is both iterator and iterable.&lt;/li&gt;
&lt;li&gt;When it's one object, and it is exhausted, we can't get a new iterator, so we can only iterate over such iterable once.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="iterable"></category><category term="list"></category><category term="set"></category><category term="dict"></category><category term="file"></category><category term="iterator"></category><category term="generator"></category></entry><entry><title>What is an iterable in Python</title><link href="https://michaeliscoding.com/what-is-an-iterable-in-python/" rel="alternate"></link><published>2021-10-19T00:00:00+02:00</published><updated>2022-04-28T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-19:/what-is-an-iterable-in-python/</id><summary type="html">&lt;p&gt;Iterable is a ubiquitous concept in Python. What exactly makes an object iterable, and which built-in objects are iterables? We'll also create our own iterables.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="What is an iterable in Python" src="https://michaeliscoding.com/images/0023-what-is-iterable-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Iterable&lt;/em&gt; (iter-able) is an object we can iterate over - we can go over its items one by one.&lt;/p&gt;
&lt;p&gt;Python &lt;a href="https://docs.python.org/3/glossary.html#term-iterable"&gt;documentation&lt;/a&gt; says it is:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An object capable of returning its members one at a time.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It might be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an object containing multiple items.&lt;/li&gt;
&lt;li&gt;an object we can split into multiple items.&lt;/li&gt;
&lt;li&gt;an object that generates items.
&lt;img alt="Contains, or can be split into or generate items" src="https://michaeliscoding.com/images/0023-what-is-an-iterable-contains-split-generate.png"&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We could also say it is an object that allows us to read its values one by one.&lt;/p&gt;
&lt;p&gt;When an object is iterable, we can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use it in &lt;code&gt;for&lt;/code&gt; loops.&lt;/li&gt;
&lt;li&gt;Use the &lt;code&gt;in&lt;/code&gt; operator to check if it contains some item.&lt;/li&gt;
&lt;li&gt;Use it as an input for &lt;a href="https://michaeliscoding.com/how-do-list-comprehensions-work-in-python/"&gt;comprehensions&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The most practical definition is probably this: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If we can use the object in a &lt;em&gt;for loop&lt;/em&gt;, it is iterable. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;First, let's look at some built-in iterable objects in Python. Then we'll explain what makes an object iterable and how it works under the bonnet.&lt;/p&gt;
&lt;h2 id="built-in-iterable-objects"&gt;Built-in iterable objects&lt;a class="headerlink" href="#built-in-iterable-objects" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="collections"&gt;Collections&lt;a class="headerlink" href="#collections" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Collections objects are containers that are used to store collections of data. We set what is in the collection when we create it, and for mutable collections, we can also add items to them later.&lt;/p&gt;
&lt;p&gt;All collections objects are iterable:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt; (and &lt;code&gt;deque&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tuple&lt;/code&gt; ( and &lt;code&gt;namedtuple&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; ( and &lt;code&gt;frozenset&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# list
my_list = ['one', 'two', 'three']
for i in my_list:
    print(i)

# tuple
my_tuple = ('one', 'two', 'three')
for i in my_tuple:
    print(i)

# set
my_set = {'one', 'two', 'three'}
for i in my_set:
    print(i)

# all 3 above output: 
# one
# two
# three
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dict&lt;/code&gt; is also iterable, but when we iterate over a dict, we iterate over its keys only:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_dict = {'a': 1, 'b': 2, 'c': 3}
for i in my_dict:
    print(i)
# outputs: 
# a
# b
# c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="Iterating over a dict" src="https://michaeliscoding.com/images/0023-what-is-an-iterable-dict.png"&gt;&lt;/p&gt;
&lt;h3 id="strings-files-and-generators"&gt;Strings, files and generators&lt;a class="headerlink" href="#strings-files-and-generators" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Many other objects are iterable, although their purpose is not to store some items for us. These objects contain data that can be split into smaller parts or generate some data that we can get one by one. We do not put things into these objects, but we can still read their content using iteration.&lt;/p&gt;
&lt;p&gt;Probably the most common iterable is  &lt;code&gt;str&lt;/code&gt; -  we can iterate over its characters:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;s = 'hey'
for i in s:
    print(i)
# h
# e
# y
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another object which is also iterable is a &lt;em&gt;&lt;a href="https://docs.python.org/3/glossary.html#term-file-object"&gt;file object&lt;/a&gt;&lt;/em&gt; (specifically &lt;em&gt;&lt;a href="https://docs.python.org/3/glossary.html#term-text-file"&gt;text file object&lt;/a&gt;&lt;/em&gt;). When iterating over a text file object, each line in the file is one item.&lt;/p&gt;
&lt;p&gt;If we had a file &lt;em&gt;lines.txt&lt;/em&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;line 1
line 2
line 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then it would work like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;with open('lines.txt') as my_file:
    for i in my_file:
        print(i)

# outputs:
# line 1
# line 2
# line 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="Iterating over a file" src="https://michaeliscoding.com/images/0023-what-is-an-iterable-file.png"&gt;&lt;/p&gt;
&lt;p&gt;All generators are also iterable. Generators are objects that yield values.&lt;/p&gt;
&lt;p&gt;Say we write a generator function that yields doubles of numbers up to the number provided as an argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def doubles(up_to):
    number = 0
    while number &amp;lt; up_to:
        number = number + 1
        yield number * 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then iterate over the values it produces:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;for x in doubles(3):
    print(str(x))

# outputs:
# 2
# 4
# 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="what-makes-an-object-iterable"&gt;What makes an object iterable?&lt;a class="headerlink" href="#what-makes-an-object-iterable" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To iterate over an &lt;em&gt;iterable&lt;/em&gt;, Python first needs to get an &lt;strong&gt;iterator&lt;/strong&gt; (iter-ator) for the &lt;em&gt;iterable&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Iterator&lt;/strong&gt; is an object that does the actual iteration over an &lt;em&gt;iterable&lt;/em&gt;. It feeds data from iterable to the outside world one by one. Iter-ator is used by the &lt;code&gt;for loop&lt;/code&gt; to get items one by one.&lt;/p&gt;
&lt;p&gt;Based on this, we can say that what makes an object &lt;em&gt;iterable&lt;/em&gt; is the fact that we can get an iter-ator for it. &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is no iterable without an iterator.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="Iterable needs iterator" src="https://michaeliscoding.com/images/0023-what-is-an-iterable-iterator.png"&gt;&lt;/p&gt;
&lt;p&gt;Ok, so how do we get an iterator for an &lt;em&gt;iterable&lt;/em&gt;?&lt;/p&gt;
&lt;h3 id="getting-the-iterator"&gt;Getting the iterator&lt;a class="headerlink" href="#getting-the-iterator" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To get an iterator for an object, Python uses the built-in function &lt;code&gt;iter()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This function takes one argument - an object we want to iterate over. &lt;/p&gt;
&lt;p&gt;If the object is &lt;em&gt;iterable&lt;/em&gt;,  &lt;code&gt;iter()&lt;/code&gt; returns an &lt;em&gt;iter-ator&lt;/em&gt; for it. If the object is not iterable, it raises &lt;code&gt;TypeError&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;We pass to &lt;code&gt;iter()&lt;/code&gt; a list of numbers in the following code. We get back a &lt;code&gt;list_iterator&lt;/code&gt; object.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; numbers = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; iter(numbers)
&amp;lt;list_iterator object at 0x10bf13b20&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following code passes just the number 5 to the &lt;code&gt;iter()&lt;/code&gt; function. It raises &lt;em&gt;TypeError&lt;/em&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; iter(5)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'int' object is not iterable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="iter() gets iterator or TypeError" src="https://michaeliscoding.com/images/0023-what-is-an-iterable-iter.png"&gt;&lt;/p&gt;
&lt;h3 id="how-does-iter-gets-an-iterator-for-an-object"&gt;How does &lt;code&gt;iter()&lt;/code&gt; gets an iterator for an object?&lt;a class="headerlink" href="#how-does-iter-gets-an-iterator-for-an-object" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are two ways &lt;code&gt;iter()&lt;/code&gt; can get an iter-ator for &lt;em&gt;iterable&lt;/em&gt;.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Iterable has a method &lt;code&gt;__iter__(self)&lt;/code&gt;.  &lt;br&gt;
    This method should return an iterator for this iterable. In this case, the iterable itself is responsible for returning its iterator. In Python 3, all built-in iterables we discussed above have the &lt;code&gt;__iter__()&lt;/code&gt; method.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The second way is that iterable has a method &lt;code&gt;__getitem__(self, index)&lt;/code&gt;.  &lt;br&gt;
    This method returns a value for a given index - if there is no such index, it raises an error. So, in this case, iterable is not providing the iterator.  The &lt;code&gt;iter()&lt;/code&gt; function needs to find an iterator for the iterable.  &lt;br&gt;
    How?  &lt;br&gt;
    When an object has &lt;code&gt;__getitem__()&lt;/code&gt; method, Python considers it a sequence or map — an object that stores items we can retrieve by their index or key. For these, Python provides several built-in iterators for iteration over sequences, dict and other forms. So &lt;code&gt;iter()&lt;/code&gt; will use and return one of those built-in itera-tors. Those iterators will use the &lt;code&gt;__getitem__()&lt;/code&gt; method to get items from the iterable, as we'll see later.  &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;(Before Python 3, the &lt;code&gt;__getitem__&lt;/code&gt; was the only way to make things iterable. This way of making objects iterable works mostly for compatibility reasons as all iterables in Python 3 have the &lt;code&gt;__iter__()&lt;/code&gt; method.)&lt;/p&gt;
&lt;p&gt;The following image shows how the &lt;code&gt;iter()&lt;/code&gt; function gets an iter-ator for an &lt;em&gt;iterable&lt;/em&gt;:&lt;br&gt;
&lt;img alt="How iter() works" src="https://michaeliscoding.com/images/0023-what-is-an-iterable-how-iter-works.png"&gt;&lt;/p&gt;
&lt;h2 id="creating-our-own-iterable"&gt;Creating our own iterable&lt;a class="headerlink" href="#creating-our-own-iterable" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now let's have a quick look at how we can create our own iterable by implementing the &lt;code&gt;__getitem__()&lt;/code&gt; method so Python will provide us built-in iterator.&lt;/p&gt;
&lt;p&gt;We will look at the &lt;code&gt;__iter__()&lt;/code&gt; method later when we discuss iterators in detail.&lt;/p&gt;
&lt;p&gt;Here's a sample implementation of an iterable object that has the &lt;code&gt;__getitem__()&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class ZeroToThreeObject:
    def __getitem__(self, index):
        if index &amp;lt;= 3:
            return index * 2
        else:
            raise IndexError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our class &lt;code&gt;ZeroToThreeObject&lt;/code&gt; is not very useful, but it is iterable.
In the &lt;code&gt;__getitem__&lt;/code&gt; method, we check if the parameter &lt;em&gt;index&lt;/em&gt; is 3 or less
and if so, we return the double of it. Otherwise, we raise &lt;em&gt;IndexError&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Let's now check what happens when we pass our object to the &lt;code&gt;iter()&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;&amp;gt;&amp;gt;&amp;gt; zero_three = ZeroToThreeObject()
&amp;gt;&amp;gt;&amp;gt; iter(zero_three)
&amp;lt;iterator object at 0x10be21810&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that we got iterator from &lt;code&gt;iter()&lt;/code&gt; function for our object. It works because our object has &lt;code&gt;__getitem__()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;So our object is iterable, and  we can  use it as such:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;zero_three = ZeroToThreeObject()

for x in zero_three:
    print(str(x))

# outputs:
# 0
# 2
# 4
# 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's worth noting that this object is not only iterable but also a sequence  (because it has &lt;code&gt;__getitem__&lt;/code&gt; method - as we discussed before), so we can access its items by index too:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;zero_three = ZeroToThreeObject()
zero_three[1]
# outputs: 2

zero_three[3]
#outputs: 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="what-iterable-isnt"&gt;What iterable isn't&lt;a class="headerlink" href="#what-iterable-isnt" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Iterable&lt;/em&gt; is a very useful concept as it abstracts away many details about a particular object. Many functions take an iterable as a parameter without specifying if it should be a list, string, generator etc. &lt;/p&gt;
&lt;p&gt;When a function expects iterable, it expects to be able to iterate over it once. 
If it expects iterable, it can't expect that object will have a length as, e.g. str or list, nor can it expect it will be able to get items from it based on the index or a key as, e.g. list or dict. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Iterable is not required to have a length - it might not work with the &lt;code&gt;len()&lt;/code&gt; function. &lt;/li&gt;
&lt;li&gt;Iterable is not required to support indexing - we might not be able to get the item from it with index. &lt;/li&gt;
&lt;li&gt;Iterable might even be infinite (usually generators).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The only thing iterable provides is that we can iterate over its items one by one.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;An &lt;strong&gt;iterable&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is an object we can iterate over (its values).&lt;/li&gt;
&lt;li&gt;can be used in a &lt;em&gt;for loop&lt;/em&gt; to get its items.&lt;/li&gt;
&lt;li&gt;is an object for which we can get an iter-ator.&lt;/li&gt;
&lt;li&gt;There is no iter-able without an iter-ator.&lt;/li&gt;
&lt;li&gt;We can use the &lt;code&gt;in&lt;/code&gt; operator to check if it contains some value.&lt;/li&gt;
&lt;li&gt;A lot of built-in objects are &lt;em&gt;iterables&lt;/em&gt;: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;dict&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;,
  &lt;code&gt;file&lt;/code&gt; etc.&lt;/li&gt;
&lt;li&gt;Generators are also &lt;em&gt;iterable&lt;/em&gt; (they generate items).&lt;/li&gt;
&lt;li&gt;We can make our objects &lt;em&gt;iterable&lt;/em&gt; by providing the &lt;code&gt;__iter__()&lt;/code&gt; method, which returns an iterator.&lt;/li&gt;
&lt;li&gt;Or by providing the &lt;code&gt;__getitem__(self, index)&lt;/code&gt; method, which returns the value at the given index.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="iterable"></category><category term="list"></category><category term="set"></category><category term="dict"></category><category term="file"></category><category term="iterator"></category><category term="generator"></category><category term="__iter__()"></category><category term="iter()"></category></entry><entry><title>Why is the first index of the array (list) 0?</title><link href="https://michaeliscoding.com/why-is-first-index-of-array-0/" rel="alternate"></link><published>2021-10-14T00:00:00+02:00</published><updated>2022-04-25T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-14:/why-is-first-index-of-array-0/</id><summary type="html">&lt;p&gt;The index of the first item in the array (list) is 0. This article explains why that is.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Why is the first index of the array (list) 0?" src="https://michaeliscoding.com/images/0022-why-is-first-index-of-array-0.jpg"&gt;&lt;/p&gt;
&lt;p&gt;To get the first item from an array(list) by index, we need to use index 0.&lt;/p&gt;
&lt;p&gt;But why it is 0 and not 1?&lt;/p&gt;
&lt;h2 id="history"&gt;History&lt;a class="headerlink" href="#history" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the old days of programming, when programmers had to deal with memory allocation and assembler language, people started to develop higher-level languages. &lt;/p&gt;
&lt;p&gt;Higher-level language in those days meant that we didn't have to write 
assembler (which could have different instructions for different processors). 
So by higher-level language here, we mean something like C.&lt;/p&gt;
&lt;h2 id="how-memory-looks"&gt;How memory looks&lt;a class="headerlink" href="#how-memory-looks" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can imagine memory as a rectangle divided into equally big parts where each part has its number. &lt;/p&gt;
&lt;p&gt;Or it can be like a small town with the shape of a rectangle where each house has its number.&lt;/p&gt;
&lt;p&gt;It looks something like this:
&lt;img alt="How physical memory looks" src="https://michaeliscoding.com/images/0022-why-first-index-is-0-memory.png" width="329"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each box represents one byte. &lt;/li&gt;
&lt;li&gt;One byte can store a number up to 255.&lt;/li&gt;
&lt;li&gt;One byte = 8bits. 8 bits means it has eight places for 1s and 0s.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, this is a one byte representing the number 25: &lt;em&gt;00011001&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For bigger numbers, we need more bytes, e.g. for number 1776, we need 2 bytes, and it would look like this: &lt;em&gt;0000011011110000&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Memory is usually our RAM. Each byte in memory has its address. Memory is linear, so the further we go, the bigger its address. Exactly like with streets.    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="how-does-array-list-in-python-work"&gt;How does array (list in Python) work?&lt;a class="headerlink" href="#how-does-array-list-in-python-work" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When we want to create an array in C, we first need to allocate memory.&lt;/p&gt;
&lt;p&gt;The question is, how much memory do we need?&lt;/p&gt;
&lt;p&gt;To allocate memory for an array, we need to know two things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How many items do we want to store in an array.&lt;/li&gt;
&lt;li&gt;What kind of items (values) do we want to store in an array - different values have different sizes, e.g. int (−32,767, +32,767) takes  2 bytes (16 bits), but long takes 4 bytes (32 bits).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So if we want an array for three ints, we need to allocate 6 bytes, but if we want an array for two longs, we need to allocate 8 bytes.&lt;/p&gt;
&lt;p&gt;So now that we know how much memory we need, we can go ahead and allocate it.&lt;/p&gt;
&lt;p&gt;What we get back from the function which allocates the memory (malloc()) is a pointer to the physical address in memory. And we store it in a variable.&lt;/p&gt;
&lt;p&gt;So our variable, let's call it &lt;code&gt;my_array&lt;/code&gt;, now points to some place in our computer's memory, and that's where the operating system will physically store our data (ints, longs, whatever).&lt;/p&gt;
&lt;h3 id="but-how-do-we-refer-to-an-individual-items-in-array"&gt;But how do we refer to an individual items in array?&lt;a class="headerlink" href="#but-how-do-we-refer-to-an-individual-items-in-array" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As we know, we use indexes. But what is an index really?&lt;/p&gt;
&lt;p&gt;To get to some item in our array, we need to know its address in memory.&lt;/p&gt;
&lt;p&gt;How do we get it? We have the address of the beginning of the array in our pointer - variable &lt;code&gt;my_array&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can use the address of the array to get what is at the beginning of the array.
So the address of the first item in the array is the same as the address of the whole array. 
Good.&lt;/p&gt;
&lt;p&gt;How do we get the address of the second item in the array?&lt;/p&gt;
&lt;p&gt;That's where information about what kind of item we store in the array is now helpful again.&lt;/p&gt;
&lt;p&gt;If we store &lt;code&gt;int&lt;/code&gt; values, we know that one &lt;code&gt;int&lt;/code&gt; has 2 bytes. So the address of the 2nd item in our array is the address of the array + 2 bytes.&lt;/p&gt;
&lt;p&gt;Where is 3rd item? Address of our array + 2 times 2 bytes.&lt;/p&gt;
&lt;p&gt;See the pattern here?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1st item: the address of array + &lt;strong&gt;0&lt;/strong&gt;* size of the item.&lt;/li&gt;
&lt;li&gt;2nd item: the address of array + &lt;strong&gt;1&lt;/strong&gt; * size of the item.&lt;/li&gt;
&lt;li&gt;3rd item: the address of array  +  &lt;strong&gt;2&lt;/strong&gt; * size of the item.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;So index actually means offset.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It tells us what is the offset from the beginning of the array.&lt;/p&gt;
&lt;p&gt;If our pointer &lt;code&gt;my_array&lt;/code&gt; would point to a memory address 100, then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The address of the &lt;em&gt;1st&lt;/em&gt; item is &lt;strong&gt;100&lt;/strong&gt; (same as the array's address, they're at the same place): 100 + 0 time 2 bytes.&lt;/li&gt;
&lt;li&gt;The address of the &lt;em&gt;2nd&lt;/em&gt; item is &lt;strong&gt;102&lt;/strong&gt;: 100 + 1 time 2 bytes.&lt;/li&gt;
&lt;li&gt;The address of the &lt;em&gt;3rd&lt;/em&gt; item is &lt;strong&gt;104&lt;/strong&gt;: 100 + 2 times 2 bytes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See the picture for a visual explanation.
&lt;img alt="Array of 2 ints in memory" src="https://michaeliscoding.com/images/0022-why-first-index-is-0-array-in-memory.png"&gt;&lt;/p&gt;</content><category term="Programming"></category><category term="python"></category><category term="list"></category><category term="array"></category></entry><entry><title>Lists are arrays in Python</title><link href="https://michaeliscoding.com/lists-are-arrays-in-python/" rel="alternate"></link><published>2021-10-12T00:00:00+02:00</published><updated>2022-04-25T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-12:/lists-are-arrays-in-python/</id><summary type="html">&lt;p&gt;Lists in Python are actually arrays - with all the consequences.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Lists are arrays in Python" src="https://michaeliscoding.com/images/0021-lists-are-arrays-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Lists in Python are arrays - with all the consequences.&lt;/p&gt;
&lt;h2 id="why-is-this-important"&gt;Why is this important?&lt;a class="headerlink" href="#why-is-this-important" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It is vital to understand how Python implements lists and  how they work, 
so we can decide if they are the proper collection for our values.&lt;/p&gt;
&lt;p&gt;Different collections have different performance characteristics for reading and writing.&lt;/p&gt;
&lt;p&gt;Choosing a proper collection ensures we will get the performance we need for a given task.&lt;/p&gt;
&lt;h2 id="what-is-an-array"&gt;What is an array?&lt;a class="headerlink" href="#what-is-an-array" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Traditionally (in C and similar languages), array stores values of the same 
type and stores them sequentially in physical memory, one after the other.
&lt;img alt="Array stores values sequantially in memory" src="https://michaeliscoding.com/images/0021-lists-are-arrays-in-python-sequentially.jpg"&gt;&lt;/p&gt;
&lt;p&gt;This memory layout makes arrays fast to read as we just read one chunk of memory sequentially, and we don't need to jump back and forth.&lt;/p&gt;
&lt;p&gt;Arrays are also very fast when accessing items by index - as we can get the memory address of an item in the array by doing simple arithmetic.
&lt;img alt="Array stores values sequantially in memory" src="https://michaeliscoding.com/images/0021-lists-are-arrays-in-python-array-arithmetic.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Traditionally we can't change the length of the array. &lt;/p&gt;
&lt;p&gt;If we want to add or remove items from an array, we must create a new array and copy values to it. &lt;/p&gt;
&lt;p&gt;&lt;em&gt;Why?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Because the extra memory we need is right after our array's
memory and is probably occupied. So if we want to add an item to the array, we need to allocate a new chunk of memory that will be big enough for all items and copy all items from the old array and write our new item there.&lt;/p&gt;
&lt;p&gt;So now, when we understand what an array is and how it works, we can discuss how a list in Python behaves.&lt;/p&gt;
&lt;h2 id="how-list-works-in-python"&gt;How list works in Python&lt;a class="headerlink" href="#how-list-works-in-python" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;How do lists work in Python?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.python.org/3/faq/design.html#how-are-lists-implemented-in-cpython"&gt;Here is a link&lt;/a&gt; to the Python documentation that discusses list implementation briefly.&lt;/p&gt;
&lt;p&gt;The documentation says lists are variable-length arrays.&lt;/p&gt;
&lt;p&gt;A variable-length array means that its length can change, either by
adding/inserting items or removing them. This flexibility is good, and it looks simple from the outside. &lt;/p&gt;
&lt;p&gt;Internally though, Python still has to reallocate memory and move items for us, so we don't have to do it. But it still needs to happen. &lt;/p&gt;
&lt;p&gt;That's why &lt;strong&gt;it is slow to insert into an array&lt;/strong&gt;. Or append to it.&lt;/p&gt;
&lt;p&gt;Python applies some cleverness to make appending faster, as mentioned in the documentation.&lt;br&gt;
When we append to a list, Python allocates more memory for a list than needed.
This overallocation makes appending faster because when we append next time, some extra memory is already allocated, and allocation and copying don't need to happen again.&lt;/p&gt;
&lt;p&gt;&lt;img alt="List allocates extra memory" src="https://michaeliscoding.com/images/0021-lists-are-arrays-in-python-extra-memory.jpg"&gt;&lt;/p&gt;
&lt;p&gt;And the bigger the list is, the more memory Python over allocates (as it assumes more appends are coming).&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import sys
numbers = []
sys.getsizeof(numbers)
# outputs: 56
# List allocates 56 bytes of memory

numbers.append(1)
sys.getsizeof(numbers)
# outputs: 88
# List now allocates 88 bytes, list had to be reallocated

numbers.append(2)
sys.getsizeof(numbers)
# outputs: 88
# List still allocates 88 bytes, no reallocation or copying happened

numbers.append(3)
sys.getsizeof(numbers)
# outputs: 88
# List still allocates 88 bytes, no reallocation or copying happened

# Let's add 10 more numbers
for n in range (10):
    numbers.append(n)

sys.getsizeof(numbers)
# outputs: 184

numbers.append(22)
sys.getsizeof(numbers)
# outputs:184
# List still allocates 184 bytes, no reallocation or copying happened
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="list-stores-pointers"&gt;List stores pointers&lt;a class="headerlink" href="#list-stores-pointers" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Before, we mentioned that arrays store values of the same type.&lt;/p&gt;
&lt;p&gt;But a list doesn't have to contain items of the same type. How's that?&lt;/p&gt;
&lt;p&gt;The reason is that Python's list doesn't store actual values but rather pointers (references) to them. &lt;/p&gt;
&lt;p&gt;Pointer is the memory address. So pointer tells us at which address the actual data are.
Each pointer has the same size, so a list in Python is an array of pointers to values, not an array of actual values. 
&lt;img alt="List allocates extra memory" src="https://michaeliscoding.com/images/0021-lists-are-arrays-in-python-pointers.jpg"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So Python's lists are true arrays with some extra bits to make them more convenient to use.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Python lists are arrays with variable lengths.&lt;/li&gt;
&lt;li&gt;That makes them very fast for reading and accessing items by index.&lt;/li&gt;
&lt;li&gt;But slow for inserting/removing.&lt;/li&gt;
&lt;li&gt;Python has some optimisations, so append is not that slow on average.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="list"></category><category term="array"></category></entry><entry><title>Tuple comprehensions in Python</title><link href="https://michaeliscoding.com/tuple-comprehensions-in-python/" rel="alternate"></link><published>2021-10-07T00:00:00+02:00</published><updated>2022-04-22T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-07:/tuple-comprehensions-in-python/</id><summary type="html">&lt;p&gt;Python does not have tuple comprehensions. But there is a way.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Tuple comprehensions in Python" src="https://michaeliscoding.com/images/0020-tuple-comprehensions-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;In Python, we have comprehensions for &lt;a href="https://michaeliscoding.com/how-do-list-comprehensions-work-in-python/"&gt;lists&lt;/a&gt;, &lt;a href="https://michaeliscoding.com/how-to-use-set-comprehensions-in-python/"&gt;sets&lt;/a&gt; and &lt;a href="https://michaeliscoding.com/how-to-use-dict-comprehensions-in-python/"&gt;dicts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;But there is no comprehension for tuples. Or is there?&lt;/p&gt;
&lt;h2 id="why-there-is-not-a-tuple-comprehension"&gt;Why there is not a tuple comprehension?&lt;a class="headerlink" href="#why-there-is-not-a-tuple-comprehension" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Firstly, the tuple is usually not used to store a series of homogenous data. We use it more often to store heterogeneous data as a quick way to group related data together.&lt;/p&gt;
&lt;p&gt;Secondly, we create a tuple with round brackets: &lt;code&gt;t1 = (1, 2)&lt;/code&gt;, so tuple comprehension would probably need to look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;my_tuple = (item for item in some_iterable)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this syntax is already used for generator expressions. So the above code returns a generator object.
We will discuss generator expressions some other time. (If you don't know what they are yet, don't worry, you can go far without them.)&lt;/p&gt;
&lt;h2 id="why-might-we-need-it"&gt;Why might we need it?&lt;a class="headerlink" href="#why-might-we-need-it" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes we want to store homogenous data in a tuple.&lt;/p&gt;
&lt;p&gt;One reason might be that there is no immutable (frozen) list in Python (not in the standard library).
Some teams want to have an immutable collection type in place of a list to make sure that once a list is created, it is not changed. &lt;/p&gt;
&lt;p&gt;Tuple fits this requirement. It behaves like a list and has all the characteristics of a list when reading a tuple. (And that is enough because since it is immutable, we don't want to write to it).&lt;/p&gt;
&lt;p&gt;So what can we do if we want to use a tuple instead of a list but still enjoy
the beauty of a comprehension?&lt;/p&gt;
&lt;h2 id="we-can-have-tuple-comprehension-almost"&gt;We can have tuple comprehension (almost)&lt;a class="headerlink" href="#we-can-have-tuple-comprehension-almost" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Ok, so how can we have tuple comprehension?&lt;/p&gt;
&lt;p&gt;Usually, a tuple is constructed only with round brackets or even without:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# with brackets
t1 = (1, 2, 3)
# outputs: (1, 2, 3)

# without brackets
t2 = 8,9
# outputs: (8, 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But a tuple is a proper class (object), so we can also create a tuple as any other object - instantiate it using its class name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t3 = tuple()
t3
# outputs: ()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, this is not useful. Let's have a look at the &lt;a href="https://docs.python.org/3/library/stdtypes.html#tuple"&gt;documentation&lt;/a&gt; to see what the tuple class looks like:
&lt;img alt="tuple documentation" src="https://michaeliscoding.com/images/0020-tuple-comprehension-doc.png"&gt;&lt;/p&gt;
&lt;p&gt;So tuple can be constructed using tuple class and passing it some iterable, e.g. list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t4 = tuple([22, 33])
t4
# outputs: (22, 33)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If it takes a list,  we can use list comprehension too:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3]
t5 = tuple([n * 2 for n in numbers])
t5
# outputs: (2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code is a bit lengthy; there are a lot of brackets.  &lt;/p&gt;
&lt;p&gt;It also allocates memory for all the items we want to have in a tuple twice. We first create a list (allocates memory) which is then used to create a tuple with the same items(allocates memory again). Yes, memory for the list is released right after the tuple is created, but the memory still needs to be available.&lt;/p&gt;
&lt;p&gt;We can do better. &lt;/p&gt;
&lt;p&gt;As seen in the documentation, a tuple accepts iterable as an argument. &lt;/p&gt;
&lt;p&gt;As the documentation says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;iterable may be either a sequence, a container that supports iteration, or an iterator object.    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="tuple documentation" src="https://michaeliscoding.com/images/0020-tuple-comprehension-doc-iterator.png"&gt;&lt;/p&gt;
&lt;p&gt;An &lt;em&gt;iterator&lt;/em&gt; is an object that enables us to iterate (traverse) over an iterable, but it is also iterable itself. &lt;/p&gt;
&lt;p&gt;We don't want to unnecessarily allocate memory for all items; thus, we will use a generator. A generator generates one value at a time (instead of allocating memory for all items). &lt;/p&gt;
&lt;p&gt;And the easiest way to create a generator is to use generator expression:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;(n * 2 for n in numbers)
# outputs &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x10c643370&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use this directly when creating our tuple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t6 = tuple((n * 2 for n in numbers))
t6
# outputs: (2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's better (in terms of memory), but there are still a lot of brackets. &lt;/p&gt;
&lt;p&gt;Luckily generator expression doesn't have to be parenthesised if it is sole 
argument into the function so we can write it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t7 = tuple(n * 2 for n in numbers)
t7
# outputs: (2, 4, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's it. That is as close to tuple comprehension as we can get. It does require using &lt;code&gt;tuple&lt;/code&gt; in front of our "comprehension", but otherwise, it's the same. It is also memory efficient. It doesn't create a list and then a tuple, so it doesn't allocate memory unnecessarily.&lt;/p&gt;
&lt;h2 id="performance"&gt;Performance&lt;a class="headerlink" href="#performance" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I've got some bad news here. It is slower than list comprehension. &lt;/p&gt;
&lt;p&gt;Here is the simple measurement for list comprehension that creates a list from 100 numbers and doubles each of them:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;% python3 -m timeit -s 'numbers=list(range(100))' 'l = [i*2 for i in numbers]'
100000 loops, best of 5: 3.4 usec per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.4 microseconds.&lt;/p&gt;
&lt;p&gt;And this is the measurement when we create a tuple instead, using our generator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt; % python3 -m timeit -s 'numbers=list(range(100))' 't = tuple(i*2 for i in numbers)'
50000 loops, best of 5: 4.79 usec per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.79 microseconds. So it's about 40% slower.&lt;/p&gt;
&lt;p&gt;Let's try a version where we create a tuple by passing it a list comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;% python3 -m timeit -s 'numbers=list(range(100))' 't = tuple([i*2 for i in numbers])'
100000 loops, best of 5: 3.6 usec per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.6 microseconds. So this is still faster to execute than the version with 
a generator, and we still end up with a tuple. As mentioned before, it allocates memory twice, so be careful when working with large data. &lt;/p&gt;
&lt;p&gt;Performance (or memory usage) is the price we need to pay if we want to use a tuple as an immutable list.&lt;/p&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;There is no real tuple comprehension in Python. &lt;/li&gt;
&lt;li&gt;We can get very close to it in terms of syntax if we use the tuple class and generator &lt;code&gt;tuple(i for i in iterable)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;But it is slower than list comprehensions.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="tuple"></category><category term="comprehension"></category></entry><entry><title>How nested comprehensions work in Python</title><link href="https://michaeliscoding.com/how-nested-comprehensions-work-in-python/" rel="alternate"></link><published>2021-10-05T00:00:00+02:00</published><updated>2022-04-21T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-05:/how-nested-comprehensions-work-in-python/</id><summary type="html">&lt;p&gt;We can nest comprehensions the same way as we can nest for loops. In this article, we explain how it works.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How nested comprehensions work in Python" src="https://michaeliscoding.com/images/0019-nested-comprehensions-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We have looked at &lt;a href="https://michaeliscoding.com/how-do-list-comprehensions-work-in-python/"&gt;list&lt;/a&gt;, &lt;a href="https://michaeliscoding.com/how-to-use-set-comprehensions-in-python/"&gt;set&lt;/a&gt; and &lt;a href="https://michaeliscoding.com/how-to-use-dict-comprehensions-in-python/"&gt;dict&lt;/a&gt; comprehensions in previous articles.&lt;/p&gt;
&lt;p&gt;We have seen how comprehensions work and how we can use them for filtering and transforming iterables to list, set or dict. &lt;/p&gt;
&lt;p&gt;There is one thing left to discuss still.&lt;/p&gt;
&lt;p&gt;We know that we can write any comprehension as a normal &lt;em&gt;for loop&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Sometimes we need a &lt;em&gt;for loop&lt;/em&gt; in a &lt;em&gt;for loop&lt;/em&gt;, for example, when we have nested data structures such as a list of lists. &lt;/p&gt;
&lt;p&gt;Below is a list that contains other lists, and they contain numbers:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;list_of_lists = [
    [1, 2],
    [3, 4, 5],
    [6, 7, 8]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="nesting"&gt;Nesting&lt;a class="headerlink" href="#nesting" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;How would we turn the above list of lists into a simple list of numbers? We would need to iterate through each list in it and then through each number in each of those lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = []
for sublist in list_of_lists:
    for n in sublist:
        numbers.append(n)

numbers
# outputs: [1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can do it also with nested list comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [n for sublist in list_of_lists for n in sublist]
numbers
# outputs: [1, 2, 3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It might be a little confusing to read it all in one line the first time. But we 
can format our comprehensions any way we like it, for example like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [n
           for sublist in list_of_lists
           for n in sublist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now it looks much more similar to normal for loops.&lt;/p&gt;
&lt;p&gt;The following image shows how nested comprehension maps to nested for loops:
&lt;img alt="How nested comprehension translates to nested for loops" src="https://michaeliscoding.com/images/0019-nested-comprehensions-loop.png"&gt;&lt;/p&gt;
&lt;p&gt;We can nest as many for loops as we need, but most of the time, it's two of them; seldom, it is three. I don't think I've seen more in production code.&lt;/p&gt;
&lt;h2 id="filtering-in-nested-comprehensions"&gt;Filtering in nested comprehensions&lt;a class="headerlink" href="#filtering-in-nested-comprehensions" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can still filter what we want to include in our results with nested comprehensions, but we need to be careful where our &lt;code&gt;if&lt;/code&gt; is.&lt;/p&gt;
&lt;p&gt;Filtering &lt;code&gt;if&lt;/code&gt; always comes right after the &lt;code&gt;for&lt;/code&gt; part of the comprehension 
which we want to filter.&lt;/p&gt;
&lt;p&gt;If we wanted only even numbers in our resulting list, we need to put &lt;code&gt;if&lt;/code&gt; after the part of comprehension that is iterating through numbers in the sublist:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[n for sublist in list_of_lists for n in sublist if n % 2 == 0]
# outputs: [2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The comprehension above would translate to the following &lt;em&gt;for loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = []
for sublist in list_of_lists:
    for n in sublist:
        if n % 2 == 0:
            numbers.append(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following image shows how the comprehension maps to the &lt;em&gt;for loop&lt;/em&gt;.
&lt;img alt="How nested comprehension with filter on inner loop maps to nested for loops" src="https://michaeliscoding.com/images/0019-nested-comprehensions-filter-inner.png"&gt;&lt;/p&gt;
&lt;p&gt;So, when a comprehension has an &lt;code&gt;if&lt;/code&gt; in it, it always belongs to the &lt;code&gt;for&lt;/code&gt; on its left.&lt;/p&gt;
&lt;p&gt;Say we want to use numbers only from lists with three numbers.&lt;/p&gt;
&lt;p&gt;To do that, we would need to filter out some lists from our &lt;code&gt;list_of_lists&lt;/code&gt;. We do it by putting &lt;code&gt;if&lt;/code&gt; right after the &lt;code&gt;for&lt;/code&gt; that iterates through &lt;code&gt;list_of_lits&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[n for sublist in list_of_lists if len(sublist) == 3 for n in sublist]
# outputs: [3, 4, 5, 6, 7, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above comprehension would translate to the following for loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = []
for sublist in list_of_lists:
    if len(sublist) == 3:
        for n in sublist:
            numbers.append(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following image shows how the comprehension maps to the &lt;em&gt;for loop&lt;/em&gt;.
&lt;img alt="How nested comprehension with filter on outer loop maps to nested for loops" src="https://michaeliscoding.com/images/0019-nested-comprehensions-filter-outer.png"&gt;&lt;/p&gt;
&lt;p&gt;During iteration at any level, the part after the &lt;code&gt;if&lt;/code&gt; is only executed if 
condition in &lt;code&gt;if&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt; - same as for normal &lt;code&gt;for&lt;/code&gt; loops.&lt;/p&gt;
&lt;p&gt;As you can guess, we can filter at all levels of comprehension if we need to.&lt;/p&gt;
&lt;p&gt;If we wanted to process only lists that have three numbers in them and put only even numbers in our resulting list, this is how we should do it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[n
 for sublist in list_of_lists if len(sublist) == 3
 for n in sublist if n % 2 == 0]

# outputs: [4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could do the same thing using a regular for loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = []
for sublist in list_of_lists:
    if len(sublist) == 3:
        for n in sublist:
            if n % 2 == 0:
                numbers.append(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And here is how the comprehension maps to the for loop:
&lt;img alt="How nested comprehension with filter on both loops maps to nested for loops" src="https://michaeliscoding.com/images/0019-nested-comprehensions-filter-both.png"&gt;&lt;/p&gt;
&lt;p&gt;Trying to keep nested comprehension in one line can quickly turn ugly, so unless we can keep it short, I suggest splitting nested comprehension into multiple lines, especially if we also use filtering.&lt;/p&gt;
&lt;p&gt;The following is still somewhat ok for an experienced developer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [n for sublist in list_of_list for n in sublist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But anything longer, I'd go for multiple lines:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;squared = [n * n
           for sublist in list_of_lists if len(sublist) == 3
           for n in sublist if n % 2 == 0]

# OR even like this
squared = [n * n
           for sublist in list_of_lists 
           if len(sublist) == 3
           for n in sublist 
           if n % 2 == 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can nest set and dict comprehension as well. Here's an example of building a dict from our &lt;code&gt;list_of_lists&lt;/code&gt; where the key is a number and the value is its square. 
Also, with filtering for even numbers and only using lists with three items:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;{n: n * n
 for sublist in list_of_lists if len(sublist) == 3
 for n in sublist if n % 2 == 0}

# outputs: {4: 16, 6: 36, 8: 64}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;comprehensions can do multiple iterations traversing nested data&lt;/li&gt;
&lt;li&gt;we can filter at any level by adding &lt;code&gt;if&lt;/code&gt; after the &lt;code&gt;for&lt;/code&gt; part of each level&lt;/li&gt;
&lt;li&gt;it works same for list, set and dict comprehensions&lt;/li&gt;
&lt;li&gt;it helps to split nested comprehension into multiple lines&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="comprehension"></category><category term="nested comprehensions"></category></entry><entry><title>How to use dict comprehensions in Python</title><link href="https://michaeliscoding.com/how-to-use-dict-comprehensions-in-python/" rel="alternate"></link><published>2021-10-01T00:00:00+02:00</published><updated>2022-04-21T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-10-01:/how-to-use-dict-comprehensions-in-python/</id><summary type="html">&lt;p&gt;What are dict comprehensions? How do they differ from list comprehensions, and when are they useful.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to use dict comprehensions in Python" src="https://michaeliscoding.com/images/0018-dict-comprehension-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We've talked about &lt;a href="https://michaeliscoding.com/how-do-list-comprehensions-work-in-python/"&gt;list&lt;/a&gt; and &lt;a href="https://michaeliscoding.com/how-to-use-set-comprehensions-in-python/"&gt;set&lt;/a&gt; comprehensions before. Comprehensions are great, and &lt;a href="https://michaeliscoding.com/why-should-we-use-comprehensions-in-python/"&gt;we should use them more&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The third and final type of comprehension in Python is &lt;em&gt;dict comprehension&lt;/em&gt;.   &lt;/p&gt;
&lt;h2 id="dict-comprehension"&gt;Dict comprehension&lt;a class="headerlink" href="#dict-comprehension" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Dict comprehension creates a dict using an existing iterable as an input.&lt;/p&gt;
&lt;p&gt;Dict comprehension has two differences from list comprehension.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We use curly brackets &lt;code&gt;{}&lt;/code&gt; instead of square brackets &lt;code&gt;[]&lt;/code&gt; (yes, same brackets as for set comprehension).&lt;/li&gt;
&lt;li&gt;Since dict needs &lt;em&gt;key&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; for each entry, our comprehension needs to return both. We do it by separating them with a colon &lt;code&gt;:&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let's have a look at how it works.&lt;/p&gt;
&lt;p&gt;Say we have a list of numbers. We want to calculate squares for our numbers and store them in dict where the key will be our number and the value will be its square.&lt;/p&gt;
&lt;p&gt;We can do it with dict comprehension like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3, 4, 5]

{n: n * n for n in numbers}

# outputs: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here is a more visual explanation:
&lt;img alt="Anatomy of dict comprehension" src="https://michaeliscoding.com/images/0018-dict-comprehension-explanation.png"&gt;&lt;/p&gt;
&lt;p&gt;We could also rewrite dict comprehension into a normal &lt;em&gt;for loop&lt;/em&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;number_squared = {}
for n in numbers:
    number_squared[n] = n * n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And this is how  the above for loop translates to the dict comprehension:&lt;/p&gt;
&lt;p&gt;&lt;img alt="How dict comprehension translates to the for loop" src="https://michaeliscoding.com/images/0018-dict-comprehension-loop.png"&gt;&lt;/p&gt;
&lt;p&gt;As with list comprehension, we can also filter which items from our input iterable we want to use. We just need to add &lt;code&gt;if&lt;/code&gt; at the end of our comprehension.
Here we will square only even numbers:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3, 4, 5]

{n: n * n for n in numbers if n % 2 ==0}

# outputs: {2: 4, 4: 16}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Dict comprehensions work similarly to list comprehensions but:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;They create a dict (not a list).&lt;/li&gt;
&lt;li&gt;They start and end with curly brackets &lt;code&gt;{}&lt;/code&gt; instead of square brackets &lt;code&gt;[]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;They require using colon &lt;code&gt;:&lt;/code&gt; between &lt;em&gt;key&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; we are returning from comprehension.&lt;/li&gt;
&lt;li&gt;That colon &lt;code&gt;:&lt;/code&gt; distinguishes them from set comprehensions that also use curly brackets.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="dict"></category><category term="comprehension"></category><category term="dict comprehension"></category></entry><entry><title>How to use set comprehensions in Python</title><link href="https://michaeliscoding.com/how-to-use-set-comprehensions-in-python/" rel="alternate"></link><published>2021-09-28T00:00:00+02:00</published><updated>2022-04-20T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-28:/how-to-use-set-comprehensions-in-python/</id><summary type="html">&lt;p&gt;What are set comprehensions? How do they differ from list comprehensions, and when are they useful.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to use set comprehensions in Python" src="https://michaeliscoding.com/images/0017-set-comprehension-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We've talked about &lt;a href="https://michaeliscoding.com/how-do-list-comprehensions-work-in-python/"&gt;list comprehension&lt;/a&gt; before. &lt;/p&gt;
&lt;p&gt;Comprehensions are great, and &lt;a href="https://michaeliscoding.com/why-should-we-use-comprehensions-in-python/"&gt;we should use them more&lt;/a&gt;. But comprehensions are not limited to lists. We can use comprehensions to build sets as well.&lt;/p&gt;
&lt;h2 id="what-is-a-set"&gt;What is a set?&lt;a class="headerlink" href="#what-is-a-set" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;set&lt;/em&gt; is an unordered collection of unique items. It can't contain the same items.&lt;/p&gt;
&lt;p&gt;It is useful when we want to make sure that we do not store duplicate items -- and we don't care about order.&lt;/p&gt;
&lt;p&gt;We define a &lt;em&gt;set&lt;/em&gt; the same way as a list, except we use curly brackets &lt;code&gt;{}&lt;/code&gt; instead of square brackets &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;unique_numbers = {1, 1, 2, 2, 3, 3}
unique_numbers
# outputs {1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above we wrote every number twice when defining our set, but the resulting set only contains each number once. That is what set does for us.&lt;/p&gt;
&lt;h2 id="set-comprehensions"&gt;Set comprehensions&lt;a class="headerlink" href="#set-comprehensions" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;What a set comprehension does? It creates a set using existing iterable as an input.&lt;/p&gt;
&lt;p&gt;Set comprehensions work the same as list comprehensions. The only difference is that they use curly brackets &lt;code&gt;{}&lt;/code&gt; instead of  square brackets &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;Here's a minimal set comprehension that uses &lt;code&gt;some_iterable&lt;/code&gt; as an input and creates a new set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;{thing for thing in some_iterable}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let's see it in action with some data. &lt;/p&gt;
&lt;p&gt;Say we have a list of numbers where some numbers are there twice. We want to square all numbers in this list - but only keep unique results.&lt;/p&gt;
&lt;p&gt;We could use list comprehension to build a list of squares:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [2, 4, 3, 4, 5, 6, 5] # 4 &amp;amp; 5 are in this list twice

squares = [n * n for n in numbers]
squares
# outputs: [4, 16, 9, 16, 25, 36, 25]
# squares 16 and 25 are there twice!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But our list of results contains numbers 16 &amp;amp; 26 twice. Not what we wanted. To fix this, we can create a set from the list:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;unique_squares = set(squares)
unique_squares
# outputs: {4, 36, 9, 16, 25}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this is not ideal because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We first create the list and then create the set.&lt;/li&gt;
&lt;li&gt;So, we do two operations.&lt;/li&gt;
&lt;li&gt;And allocate memory twice for all items.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instead, we could create a set straight away using set comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;unique_squares = {n * n for n in numbers}
unique_squares
# outputs: {4, 36, 9, 16, 25}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that's all there is to it. We just used different brackets. Our code is now shorter, faster and more memory efficient.&lt;/p&gt;
&lt;p&gt;As with list comprehension, we could rewrite a set comprehension as a &lt;code&gt;for&lt;/code&gt; loop :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;unique_squares = set()

for n in numbers:
    unique_squares.add(n*n)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can see how the above &lt;code&gt;for&lt;/code&gt; loop translates to a set comprehension:
&lt;img alt="How set comprehension translates to the for loop" src="https://michaeliscoding.com/images/0017-set-comprehension-loop.png"&gt;&lt;/p&gt;
&lt;p&gt;And of course, as with list comprehension, we can also use &lt;code&gt;if&lt;/code&gt; to filter what we want to process:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;{n * n for n in numbers if n &amp;gt; 3}
# outputs: {36, 16, 25}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Set comprehensions work in the same way as a list comprehensions but:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;they create a set (not a list)&lt;/li&gt;
&lt;li&gt;they start and end with curly brackets &lt;code&gt;{}&lt;/code&gt; (instead of square brackets &lt;code&gt;[]&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="set"></category><category term="comprehension"></category><category term="set comprehension"></category></entry><entry><title>Why should we use comprehensions in Python?</title><link href="https://michaeliscoding.com/why-should-we-use-comprehensions-in-python/" rel="alternate"></link><published>2021-09-23T00:00:00+02:00</published><updated>2022-04-20T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-23:/why-should-we-use-comprehensions-in-python/</id><summary type="html">&lt;p&gt;There are at least three good reasons why we should use comprehensions in Python. Let's see what they are.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Why should we use comprehensions in Python?" src="https://michaeliscoding.com/images/0016-why-use-comprehensions-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;While comprehensions are quite popular among Python developers, I think they're still underused.&lt;/p&gt;
&lt;p&gt;There are at least three good reasons why we should use comprehensions in Python. Let's see what they are.&lt;/p&gt;
&lt;h2 id="first-they-isolate-our-list-creation"&gt;First: They isolate our list creation&lt;a class="headerlink" href="#first-they-isolate-our-list-creation" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;They make it harder for others to interfere with our list creation.&lt;/p&gt;
&lt;p&gt;When we use a for loop, other people can come later and add things 
to our &lt;em&gt;for loop&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;Say we start with something really simple. We have a list of players. 
We want to export good players daily - those with a score of more than 100 for a given day:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;good_players = []
for player in players:
    if player.today_score &amp;gt; 100:
        good_players.append(player)

export_good(good_players)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok, that looks fine. What's the issue, then?&lt;/p&gt;
&lt;p&gt;It is too easy for others to come later and add their own things to this &lt;em&gt;for loop&lt;/em&gt; that have nothing to do with our original task. &lt;/p&gt;
&lt;p&gt;So in a few weeks, our loop ends up looking like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;good_players = []
teams = []
emails = []
daily_stats = load_stats()

for player in players:
    if player.has_played_today:
        player.update_stats(daily_stats)
        player.save()
    if player.today_score &amp;gt; 100:
        email.append(player.email)
          add_free_credit_to(player)
        if player.team_name not in teams:
            teams.append(player.team_name)
        good_players.append(player)

send_emails(emails)
process_credits()
notify_teams(teams)
export_good(good_players)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A lot is going on there. It takes much more time to understand what is happening.&lt;br&gt;
Our original feature (exporting good players) is now buried under a bunch of other things. So it is now easier to break. &lt;/p&gt;
&lt;p&gt;There is a bug in the code above. 
We repeatedly give free credits to all players; that is not right. And this is in production already! &lt;/p&gt;
&lt;p&gt;We want to give free credit only to new players who joined today and managed to earn a score of 100 or more.&lt;/p&gt;
&lt;p&gt;So someone comes in a rush, looks at the code and quickly updates the &lt;code&gt;if&lt;/code&gt; statement like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt; if player.today_score &amp;gt; 100 and player.join_date == today():
        email.append(player.email)
          add_free_credit_to(player)
        if player.team_name not in teams:
            teams.append(player.team_name)
        good_players.append(player)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now our original code is broken! We're not exporting all good players 
anymore. Only players that also joined today, which is not what we want for our export.&lt;/p&gt;
&lt;p&gt;And it all happened because it was too easy for others to add to our simple loop. That made it harder to understand, and so the person fixing the bug in a rush missed the fact that the &lt;code&gt;good_players&lt;/code&gt; list is also part of that &lt;code&gt;if&lt;/code&gt; because it was hidden after another if.&lt;/p&gt;
&lt;p&gt;Instead, with a list comprehension, we could do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;good_players = [player for player in players if player.score &amp;gt; 100]
export_good(good_players)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It isolates our list building into one expression. It makes it harder 
to break because others have no easy way to interfere with our export of 
good players.&lt;/p&gt;
&lt;p&gt;So instead of fiddling with our list comprehension, they would go to do their own thing. Others can still do for loops if needed, but our code will be independent of those and work as expected.&lt;/p&gt;
&lt;h2 id="second-theyre-very-concise-and-clear"&gt;Second: They’re very concise and clear&lt;a class="headerlink" href="#second-theyre-very-concise-and-clear" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Clarity is essential because code is written once and read many times. &lt;/p&gt;
&lt;p&gt;We don't want to unnecessarily read pages and pages of code if it could be written more concisely. I intentionally said concise, which is not the same as short.  &lt;/p&gt;
&lt;p&gt;For a programmer who knows comprehensions, it is faster to understand a comprehension than a &lt;em&gt;for loop&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;For loop might do many things, list comprehension always does one thing - creates a new list from another iterable.&lt;/p&gt;
&lt;p&gt;Concise code is easier to read and understand and thus easier and cheaper to maintain.&lt;/p&gt;
&lt;h2 id="third-they-are-faster-than-for-loops"&gt;Third:  They are faster than  &lt;em&gt;for loops&lt;/em&gt;&lt;a class="headerlink" href="#third-they-are-faster-than-for-loops" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Comprehensions are faster than &lt;em&gt;for loops&lt;/em&gt;  if we use them where they should be used.&lt;/p&gt;
&lt;p&gt;Explaining in detail why that is the case is outside the scope of this article 
but in short, comprehensions are optimised and executed at the C level rather than at the Python level.&lt;/p&gt;
&lt;p&gt;Below is simple measuring. &lt;/p&gt;
&lt;p&gt;We create a list of numbers from 0 to 100. Then we make a copy of that list. First with a for loop and then with a comprehension. &lt;/p&gt;
&lt;p&gt;Comprehension is more than twice faster:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;projects % python3 -m timeit -s 'scores=list(range(100))' 'my_scores =[]' 'for n in scores: my_scores.append(n)'
50000 loops, best of 5: 4.65 usec per loop

projects % python3 -m timeit -s 'scores=list(range(100))' 'my_scores = [n for n in scores]'
200000 loops, best of 5: 1.97 usec per loop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Comprehensions make our code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;more robust (harder to break).&lt;/li&gt;
&lt;li&gt;more concise and clearer.&lt;/li&gt;
&lt;li&gt;faster.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="list"></category><category term="comprehension"></category></entry><entry><title>How do list comprehensions work in Python</title><link href="https://michaeliscoding.com/how-do-list-comprehensions-work-in-python/" rel="alternate"></link><published>2021-09-21T00:00:00+02:00</published><updated>2022-04-20T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-21:/how-do-list-comprehensions-work-in-python/</id><summary type="html">&lt;p&gt;A detailed explanation of how list comprehensions work in Python. What's their purpose. When to use them and when not to.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How do list comprehensions work in Python" src="https://michaeliscoding.com/images/0015-how-list-comprehension-works-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;List comprehensions are one of the most remarkable features in Python. They come from Haskell, and not many other languages have them.&lt;/p&gt;
&lt;p&gt;Programmers use them a lot because they're powerful, nice and short. &lt;/p&gt;
&lt;p&gt;Experienced Python programmers are expected to know about them and use them where appropriate.&lt;/p&gt;
&lt;h2 id="what-a-list-comprehension-does-and-how-does-it-work"&gt;What a list comprehension does, and how does it work?&lt;a class="headerlink" href="#what-a-list-comprehension-does-and-how-does-it-work" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;List comprehension creates a new list from an existing iterable (e.g. list, set etc.). The existing iterable is an input for the list comprehension. &lt;/p&gt;
&lt;p&gt;They may have conditions that determine if an item goes into the new list, and we can process (do something with) the item before it goes into the list—more on that in the next section.&lt;/p&gt;
&lt;p&gt;The most minimal comprehension looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[thing for thing in some_iterable]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It has three parts:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Square brackets denote the start and the end of the list comprehension.&lt;/li&gt;
&lt;li&gt;The expression whose result goes into the new list.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;for loop&lt;/em&gt; that iterates through our iterable.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ok, let's explain what is what:
&lt;img alt="What is what in list comprehension" src="https://michaeliscoding.com/images/0015-what-is-what-simple.png"&gt;&lt;/p&gt;
&lt;p&gt;Let's see it in action with some data:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;scores = [6, 3, 8, 9, 34, 11, 18]

my_scores = [number for number in scores]

print(my_scores)
# outputs: [6, 3, 8, 9, 34, 11, 18]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the code above, we create a simple list of numbers - &lt;code&gt;scores&lt;/code&gt;. Then we use comprehension to create a new list out of  &lt;code&gt;scores&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It helps to read a comprehension starting from &lt;code&gt;for&lt;/code&gt; and ending at the beginning:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;For each number in scores, put the number into the new list.&lt;/em&gt;
&lt;img alt="How to read comprehension" src="https://michaeliscoding.com/images/0015-read-comprehension.png"&gt;&lt;/p&gt;
&lt;p&gt;We could achieve the same thing with this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;new_scores = []
for number in scores:
    new_scores.append(number)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can see how this comprehension translates to the &lt;em&gt;for loop&lt;/em&gt; above:
&lt;img alt="How comprehension translates to the for loop" src="https://michaeliscoding.com/images/0015-comprehension-for-loop.png"&gt;&lt;/p&gt;
&lt;p&gt;As we can see, a list comprehension does the same thing as a for loop, but it needs only one line instead of three. &lt;/p&gt;
&lt;p&gt;So a list comprehension is a for loop and list creation in one thing - with 
better, more concise syntax.&lt;/p&gt;
&lt;p&gt;Comprehensions are also faster, but more on that later.&lt;/p&gt;
&lt;p&gt;The above examples don't do much; they just create a copy of an existing list. &lt;/p&gt;
&lt;p&gt;So when are comprehensions really useful?
They shine when we need to do mapping or filtering (or both) of values in 
iterable and produce a new list.&lt;/p&gt;
&lt;h2 id="mapping"&gt;Mapping&lt;a class="headerlink" href="#mapping" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Mapping (transforming) means that we want to take an item from the iterable, do something with it and return a new value.&lt;/p&gt;
&lt;p&gt;Let's say we want to double all scores in our list.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;scores = [6, 3, 8, 9, 34, 11, 18]

double_scores = [number * 2 for number in scores]

print(double_scores)
# outputs: [12, 6, 16, 18, 68, 22, 36]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again what is before &lt;code&gt;for&lt;/code&gt; goes to the new list:
&lt;img alt="Result of what is before 'for' goes into the new list" src="https://michaeliscoding.com/images/0015-mapping.png"&gt;&lt;/p&gt;
&lt;p&gt;And this is how it translates to the for loop:
&lt;img alt="How mapping comprehension translates to the for loop" src="https://michaeliscoding.com/images/0015-mapping-to-for-loop.png"&gt;&lt;/p&gt;
&lt;p&gt;We can also use an existing function in a comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def add100(score):
    return score+100

scores_100_more = [add100(number) for number in scores]

print(scores_100_more)
# outputs: [106, 103, 108, 109, 134, 111, 118]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The crucial thing to remember is this: the result of what is before the &lt;code&gt;for&lt;/code&gt; in the comprehension goes into the new list. Thus, it must be something that returns a value - an expression. &lt;/p&gt;
&lt;p&gt;If we call a function in the list comprehension, it should be a function that produces a meaningful value that we want to put into a new list. If we use a function that doesn't return anything, we will end with a new list full of &lt;code&gt;None&lt;/code&gt; values.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;
def write_score(score):
    SomeStorage().write(score)

useless = [write_score(number) for number in scores]

print(useless)
# outputs: [None, None, None, None, None, None, None]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sure our function could do something else, but unless it returns something that we want to use later, we should not use comprehension but rather a &lt;em&gt;for loop&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;List comprehension is for mapping and filtering.&lt;/p&gt;
&lt;h2 id="filtering"&gt;Filtering&lt;a class="headerlink" href="#filtering" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To use comprehension for filtering, we need to put &lt;code&gt;if&lt;/code&gt; at the end like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;scores = [6, 3, 8, 9, 34, 11, 18]

more_than_ten = [number for number in scores if number &amp;gt; 10]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this, the part before the &lt;code&gt;for&lt;/code&gt; will be executed and its result added to the new list only if the &lt;code&gt;if&lt;/code&gt; part evaluates to &lt;code&gt;True&lt;/code&gt;:
&lt;img alt="What is before 'for' goes into the new list only if 'if' is True" src="https://michaeliscoding.com/images/0015-filtering.png"&gt;&lt;/p&gt;
&lt;p&gt;It is the equivalent of the following &lt;em&gt;for loop&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;more_than_ten = []
for number in scores:
    if number &amp;gt; 10:
        more_than_ten.append(number)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now, while comprehension is still one short line, the for loop has grown to four lines. &lt;/p&gt;
&lt;p&gt;This image shows how comprehension translates to the for loop with &lt;code&gt;if&lt;/code&gt;:
&lt;img alt="How filtering comprehension translates to the for loop" src="https://michaeliscoding.com/images/0015-filtering-to-for-loop.png"&gt;&lt;/p&gt;
&lt;h2 id="filter-and-map-together"&gt;Filter and map together&lt;a class="headerlink" href="#filter-and-map-together" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can also filter and map at the same time. &lt;/p&gt;
&lt;p&gt;Let's say we want to give one bonus point to all players with a score of more than 10:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;scores = [6, 3, 8, 9, 34, 11, 18]

bonus = [number + 1 for number in scores if number &amp;gt; 10]
print(bonus)
# outputs: [35, 12, 19]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So this is what happened in the comprehension above:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It went through each number in &lt;code&gt;scores&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When the &lt;code&gt;if&lt;/code&gt; part on the right side was evaluated to &lt;code&gt;True&lt;/code&gt; - if the number was more than 10 - it added 1 to it, and the result went into our new list.&lt;/li&gt;
&lt;li&gt;When the &lt;code&gt;if&lt;/code&gt; part on the right side was evaluated to &lt;code&gt;False&lt;/code&gt; - for number 10 or less - it ignored that number and continued with the next one.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="formatting"&gt;Formatting&lt;a class="headerlink" href="#formatting" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When a lot is happening in our comprehension, we can always split it into multiple lines.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cards = [create_card(player)
         for player in all_players
         if is_top_player(player)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any form we like really:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;cards = [create_card(player)
         for player
         in all_players
         if is_top_player(player)]

# or
cards = [create_card(player) for player in all_players
         if is_top_player(player)]

# or
cards = [create_card(player)
         for player in all_players if is_top_player(player)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="limitations"&gt;Limitations&lt;a class="headerlink" href="#limitations" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It is important to note that the new list is assigned to the variable only after comprehension is finished. &lt;/p&gt;
&lt;p&gt;We don't have access to the list which is being created by the comprehension in the comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# This will not work `my_scores` does not exist yet
unique_names = [name  for name in all_names if name not in unique_names]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="when-to-use-comprehensions"&gt;When to use comprehensions&lt;a class="headerlink" href="#when-to-use-comprehensions" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;You should use comprehension only to create new list out of existing iterable - 
whether it is because we want to map/transform values or filter them. &lt;/p&gt;
&lt;p&gt;In these cases it is preferred to use comprehensions.&lt;/p&gt;
&lt;h2 id="when-not-to-use-comprehensions"&gt;When not to use comprehensions&lt;a class="headerlink" href="#when-not-to-use-comprehensions" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We should not use them for anything else except mapping and filtering.  &lt;/p&gt;
&lt;p&gt;They're not for general looping. For that, we should just use a &lt;em&gt;for loop&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So we shouldn't do things like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;[print(person.name) for person in people]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yes, it will print names but:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It is slower - it creates a new list (for which the system needs to allocate memory), and then it adds &lt;code&gt;None&lt;/code&gt; to it once for each person. So we'll end up with a list full of &lt;code&gt;None&lt;/code&gt; values that is useless and gets discarted.&lt;/li&gt;
&lt;li&gt;It is confusing. List comprehensions are for creating lists. If someone creates a list, it is because they want to use that list. It's not the case here. So a person looking at this will be confused about why have we done this.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;List comprehension:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;always creates a new list.&lt;/li&gt;
&lt;li&gt;can use any iterable as an input. So we can iterate through items in a tuple, set, string etc.&lt;/li&gt;
&lt;li&gt;should be used for filtering.&lt;/li&gt;
&lt;li&gt;should be used for mapping.&lt;/li&gt;
&lt;li&gt;is faster than writing a &lt;em&gt;for loop&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;should &lt;strong&gt;not&lt;/strong&gt; be used if we do not want to use or keep a resulting list.&lt;/li&gt;
&lt;/ul&gt;</content><category term="Python explained"></category><category term="python"></category><category term="list"></category><category term="comprehension"></category></entry><entry><title>How to delete files and directories in Python</title><link href="https://michaeliscoding.com/how-to-delete-files-directories-in-python/" rel="alternate"></link><published>2021-09-16T00:00:00+02:00</published><updated>2022-04-19T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-16:/how-to-delete-files-directories-in-python/</id><summary type="html">&lt;p&gt;How to delete files and directories in Python using &lt;em&gt;os&lt;/em&gt; and &lt;em&gt;shutils&lt;/em&gt; modules&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to delete files and directories in Python" src="https://michaeliscoding.com/images/0014-delete-files-directories-python.jpg"&gt;&lt;/p&gt;
&lt;h2 id="deleting-files"&gt;Deleting files&lt;a class="headerlink" href="#deleting-files" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To delete a file we use &lt;code&gt;os.remove()&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;It takes a path to a file as an argument. It can be an absolute path or a path relative to the &lt;a href="https://michaeliscoding.com/how-to-get-and-change-working-directory-in-python/"&gt;current working directory&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

os.remove('/Users/michaeliscoding/my_dir/file1.txt')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If such a file doesn't exist, it will raise &lt;code&gt;FileNotFoundError&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;If the path we provided points to a directory, not a file, it will raise an &lt;code&gt;IsADirectoryError&lt;/code&gt; or a &lt;code&gt;PermissionError&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;(&lt;a href="https://docs.python.org/3/library/os.html#os.remove"&gt;Documentation&lt;/a&gt; says it will raise &lt;code&gt;IsADirectoryError&lt;/code&gt; but on macOS it raises &lt;code&gt;PermissionError&lt;/code&gt; for me.)&lt;/p&gt;
&lt;h2 id="deleting-directories"&gt;Deleting directories&lt;a class="headerlink" href="#deleting-directories" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;o delete a directory  we need a different function - &lt;code&gt;os.rmdir()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

os.rmdir('/Users/michaeliscoding/my_dir/')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But there is a catch! It will work only if a directory is &lt;strong&gt;empty&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Otherwise, it will raise &lt;code&gt;OSError&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To make the directory empty, we would first need to delete all files and 
subdirectories it contains. But those sub-directories might also have files, 
so we would need to write a recursive function for that.&lt;/p&gt;
&lt;p&gt;Luckily, we don’t have to do that by ourselves. There is the &lt;code&gt;shuttle.rmtree()&lt;/code&gt; function that will delete directories even if they're not empty:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import shutils

shutils.rmtree('/Users/michaeliscoding/my_dir/')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This one will delete all files and directories on the given path so &lt;strong&gt;be careful&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Another function that is sometimes helpful is &lt;code&gt;os.removedirs()&lt;/code&gt;.
It removes a directory you give it and any directory leading to it (parents) if those are empty.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

os.removedirs('/Users/michaeliscoding/my_dir/')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code above would delete &lt;em&gt;my_dir&lt;/em&gt; if empty and &lt;em&gt;michaeliscoding&lt;/em&gt; if empty, and even &lt;em&gt;Users&lt;/em&gt; if empty. Since it is deleting only empty directories, there’s not that much harm 
this can cause.&lt;/p&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="directory"></category><category term="os"></category><category term="file"></category><category term="shutils"></category></entry><entry><title>How to get and change the working directory in Python</title><link href="https://michaeliscoding.com/how-to-get-and-change-working-directory-in-python/" rel="alternate"></link><published>2021-09-14T00:00:00+02:00</published><updated>2022-04-19T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-14:/how-to-get-and-change-working-directory-in-python/</id><summary type="html">&lt;p&gt;What is a working directory (CWD), and how to get it and change it in Python?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Current working directory" src="https://michaeliscoding.com/images/0013-get-and-change-working-directory-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;What is a working directory (CWD), and how to get it and change it in Python?&lt;/p&gt;
&lt;h2 id="what-is-a-current-working-directory-cwd"&gt;What is a current working directory - CWD?&lt;a class="headerlink" href="#what-is-a-current-working-directory-cwd" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The current working directory (CWD) is a directory our code operates from.&lt;/p&gt;
&lt;p&gt;It is (almost) always a directory from which we started (run) Python, whether we started REPL with &lt;code&gt;python3&lt;/code&gt; or run file with &lt;code&gt;python3 my_code.py&lt;/code&gt;. &lt;/p&gt;
&lt;h2 id="why-is-this-important"&gt;Why is this important?&lt;a class="headerlink" href="#why-is-this-important" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;CWD is important because when we work with files and directories and reference a file by name or relative path, this name or path is interpreted as relative to the CWD. &lt;/p&gt;
&lt;p&gt;Let's say CWD is &lt;code&gt;'/Users/michaeliscoding/'&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If we open a file with the name &lt;code&gt;'test.txt'&lt;/code&gt;, Python will open the file at the absolute path &lt;code&gt;'/Users/michaeliscoding/text.txt'&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If we use the relative path &lt;code&gt;'my_dir/test2.txt'&lt;/code&gt;, Python will open a file at the absolute path &lt;code&gt;'/Users/michaeliscoding/my_dir/test2.txt'&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We can also go up - if we use relative path &lt;code&gt;'../test3.txt'&lt;/code&gt; Python will open the file at absolute path &lt;code&gt;'/Users/test3.txt'&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="how-to-get-the-current-working-directory-in-python"&gt;How to get the current working directory in Python&lt;a class="headerlink" href="#how-to-get-the-current-working-directory-in-python" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can get CWD by using the function &lt;a href="https://docs.python.org/3/library/os.html#os.getcwd"&gt;&lt;code&gt;os.getcwd()&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

os.getcwd()
# outputs: '/Users/michaeliscoding/'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(You'll get a different path as an output, of course.)&lt;/p&gt;
&lt;p&gt;As we mentioned, it is almost always a directory from which we start Python.
I said almost because we can change this directory.&lt;/p&gt;
&lt;h2 id="how-to-change-the-current-working-directory"&gt;How to change the current working directory&lt;a class="headerlink" href="#how-to-change-the-current-working-directory" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can  change CWD with &lt;a href="https://docs.python.org/3/library/os.html#os.chdir"&gt;&lt;code&gt;os.chdir(path)&lt;/code&gt;&lt;/a&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

# using absolute path
os.chdir('/Users/michaeliscoding/projects/data/')

# using relative path
os.chdir('data/')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;chdir()&lt;/code&gt; will raise a &lt;code&gt;FileNotFoundError&lt;/code&gt; if the directory we want to change to does not exist.&lt;/p&gt;
&lt;p&gt;The path we give to &lt;code&gt;chdir()&lt;/code&gt; can be absolute or relative. If it's relative, it is a relative path from the CWD.&lt;/p&gt;
&lt;p&gt;Changing CWD might be helpful if we operate with files in some directory and we want to deal just with file names, not whole paths.&lt;/p&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="directory"></category><category term="os"></category><category term="cwd"></category><category term="path"></category></entry><entry><title>Common string operations in Python</title><link href="https://michaeliscoding.com/common-string-operations-in-python/" rel="alternate"></link><published>2021-09-09T00:00:00+02:00</published><updated>2022-04-13T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-09:/common-string-operations-in-python/</id><summary type="html">&lt;p&gt;This reference article covers the most common operations with strings.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Common string operations in Python" src="https://michaeliscoding.com/images/0012-common-string-operations-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;This reference article covers the most common operations with strings.&lt;/p&gt;
&lt;h2 id="very-short-but-important-intro"&gt;Very short but important intro&lt;a class="headerlink" href="#very-short-but-important-intro" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Strings in Python are immutable&lt;/strong&gt;. That means we can never change (edit) a string. We always create a new one.  Of course, we can then assign a newly created string to the same variable.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Everything is case sensitive&lt;/strong&gt; unless stated otherwise. That means &lt;em&gt;"Here"&lt;/em&gt; is NOT equal to &lt;em&gt;"here"&lt;/em&gt;, and &lt;em&gt;"two"&lt;/em&gt; is NOT equal to &lt;em&gt;"TWO"&lt;/em&gt;, etc.&lt;/p&gt;
&lt;h2 id="joining-strings"&gt;Joining strings&lt;a class="headerlink" href="#joining-strings" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can join strings in Python with a &lt;code&gt;+&lt;/code&gt;  (addition) operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;greeting = 'Hello ' + 'world!'
# 'Hello world!'

name = 'John'

'Hello ' + name
# 'Hello John'

bye = 'Bye '

bye + name
# 'Bye John'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can join more than two strings, of course. But using &lt;code&gt;+&lt;/code&gt;  to join more than a few strings is inefficient. Especially in a loop, so never do that. &lt;/p&gt;
&lt;p&gt;Instead, it's much better to use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.join"&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;directions = ['up', 'right', 'down', 'left']

'&amp;gt;'.join(directions)
# 'up&amp;gt;right&amp;gt;down&amp;gt;left'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;str.join(iterable)&lt;/code&gt; is a method of string. It takes one parameter - iterable (e.g. list, set etc.) and returns a new string.&lt;/p&gt;
&lt;p&gt;It creates a new string by joining (concatenating) strings in iterable by string separator. The separator is the string on which we call the &lt;code&gt;join()&lt;/code&gt; method  (in the code above, it's "&gt;".&lt;/p&gt;
&lt;h2 id="splitting-string"&gt;Splitting string&lt;a class="headerlink" href="#splitting-string" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes we want to split one string into multiple using some separator. For that, we use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.split"&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;names = 'John &amp;amp; Martin &amp;amp; Carla &amp;amp; Linda &amp;amp; Alena'
names.split(' &amp;amp; ')
# ['John', 'Martin', 'Carla', 'Linda', 'Alena']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;split()&lt;/code&gt; needs one argument, separator, which it uses to split the string. &lt;/p&gt;
&lt;p&gt;It also takes the optional argument &lt;code&gt;maxsplit&lt;/code&gt;, limiting how many times to split the string. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;names = 'John &amp;amp; Martin &amp;amp; Carla &amp;amp; Linda &amp;amp; Alena'
names.split(' &amp;amp; ', 2)
# ['John', 'Martin', 'Carla &amp;amp; Linda &amp;amp; Alena']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Above, we call &lt;code&gt;split()&lt;/code&gt; with the second argument &lt;code&gt;2&lt;/code&gt;, so it splits the string only twice. The remaining part is left untouched as the third item in the resulting list.&lt;/p&gt;
&lt;p&gt;When we have multiple lines in our string (e.g. from a small file or other input), it's handy to use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines"&gt;&lt;code&gt;splitlines()&lt;/code&gt;&lt;/a&gt; method, which splits a string at line boundaries, so the resulting list contains each line separately.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;data = 'First line\nSecond line\nThird line'

data.splitlines()
# ['First line', 'Second line', 'Third line']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could also use &lt;code&gt;data.split('\n')&lt;/code&gt; but advantage of &lt;code&gt;splitlines()&lt;/code&gt; is that it handles all the other line boundaries than just &lt;code&gt;\n&lt;/code&gt; (&lt;a href="https://docs.python.org/3/library/stdtypes.html#str.splitlines"&gt;doc&lt;/a&gt;).&lt;/p&gt;
&lt;h2 id="check-if-a-string-contains-a-substring"&gt;Check if a string contains a substring&lt;a class="headerlink" href="#check-if-a-string-contains-a-substring" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To check if a string contains some other string, we use the &lt;code&gt;in&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = 'one, two, three'
'two' in numbers
# True

'five' in numbers
# False
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="check-if-a-string-starts-with-a-prefix"&gt;Check if a string starts with a prefix&lt;a class="headerlink" href="#check-if-a-string-starts-with-a-prefix" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To check if a string starts with some string, we use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.startswith"&gt;&lt;code&gt;startswith()&lt;/code&gt;&lt;/a&gt; function.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;title = 'Here comes the sun'

title.startswith('Here')
# True

# Case sensitive so this will produce False
title.startswith('here')
# False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But what if we want to check if a string starts with one of the multiple prefixes? &lt;/p&gt;
&lt;p&gt;&lt;code&gt;startswith()&lt;/code&gt; also takes a tuple as a first argument so we can pass multiple prefixes to check against:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sentences = ['He is here', 'She is there', 
             'You are great', 'I am good']

# Print only sentences in third person
for s in sentences:
    if s.startswith(('He', 'She', 'It')):
        print(s)

# He is here
# She is there
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;startswith()&lt;/code&gt; also takes two optional parameters, &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;. We can use these to tell it where it should start to look for a prefix and where the search should end. Essentially it cuts our string before checking it:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;'She is there'.startswith('is', start=4)
# True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt; is not that useful for &lt;code&gt;startswith&lt;/code&gt;  but more for &lt;code&gt;endswith()&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="check-if-a-string-ends-with-a-suffix"&gt;Check if a string ends with a suffix&lt;a class="headerlink" href="#check-if-a-string-ends-with-a-suffix" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To check if a string ends with some strings, we use &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.endswith"&gt;&lt;code&gt;endswith()&lt;/code&gt;&lt;/a&gt;. It works the same as &lt;code&gt;startswith()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;title = 'Here comes the sun'

title.endswith('sun')
# True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also pass tuple as with &lt;code&gt;startswith()&lt;/code&gt; and use &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;sentences = ['He is here', 'She is there', 
             'You are great', 'I am good']

# Print only sentences ending with 'eat' or 'good'
for s in sentences:
    if s.endswith(('eat', 'good')):
        print(s)
# You are great
# I am good

'You are great'.endswith('are', 0, 7)
# True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we want to use &lt;code&gt;end&lt;/code&gt;, we need to use &lt;code&gt;start&lt;/code&gt; too - we use 0 when we don't want to ignore anything from the beginning of the string.&lt;/p&gt;
&lt;h2 id="count-occurrences-of-a-substring"&gt;Count occurrences of a substring&lt;a class="headerlink" href="#count-occurrences-of-a-substring" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When we need to know how many times substring occurs in our string, we use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.count"&gt;&lt;code&gt;count()&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;all_blue = 'I like blue shoes, blue shirts, blue hats'

all_blue.count('blue')
# 3

all_blue.count('green')
# 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method also takes &lt;code&gt;start&lt;/code&gt; and end parameters. If provided, it looks for substring only within the range between &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;all_blue = 'I like blue shoes, blue shirts, blue hats'

all_blue.count('blue', 10, 30)
# 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="length-of-a-string"&gt;Length of a string&lt;a class="headerlink" href="#length-of-a-string" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To get the length of the string,  that is, how many characters it has, we use the &lt;a href="https://docs.python.org/3/library/functions.html#len"&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;len('hello')
# 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="replacing-part-of-a-string"&gt;Replacing part of a string&lt;a class="headerlink" href="#replacing-part-of-a-string" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes we want to replace part of the string with another string. We can use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.replace"&gt;&lt;code&gt;replace(old, new)&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;all_blue = 'I like blue shoes, blue shirts, blue hats'

all_blue.replace('blue', 'green')
# 'I like green shoes, green shirts, green hats'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;replace()&lt;/code&gt; takes one optional parameter &lt;code&gt;count&lt;/code&gt;. By giving it this parameter, we can limit how many occurrences of the substring it should replace:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;all_blue = 'I like blue shoes, blue shirts, blue hats'

all_blue.replace('blue', 'green', 1)
# 'I like green shoes, blue shirts, blue hats'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="convert-string-to-lowercase"&gt;Convert string to lowercase&lt;a class="headerlink" href="#convert-string-to-lowercase" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To make all characters in string lower case, we use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.lower"&gt;&lt;code&gt;lower()&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;title = 'Here comes the sun'

title_lowercase = title.lower()
# 'here comes the sun'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lowercasing a string is often helpful when dealing with substring (contains, starts with, ends with) or comparing, and we don't care about case sensitiveness. In this case, we make everything lower case and then do our operation.&lt;/p&gt;
&lt;h2 id="convert-string-to-uppercase"&gt;Convert string to uppercase&lt;a class="headerlink" href="#convert-string-to-uppercase" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We use the &lt;a href="https://docs.python.org/3/library/stdtypes.html#str.isupper"&gt;&lt;code&gt;upper()&lt;/code&gt;&lt;/a&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;title = 'Here comes the sun'

title_uppercase = title.upper()
# 'HERE COMES THE SUN'
&lt;/code&gt;&lt;/pre&gt;</content><category term="Python reference"></category><category term="python"></category><category term="string"></category><category term="str"></category></entry><entry><title>How to read directory content in Python</title><link href="https://michaeliscoding.com/how-to-read-directory-content-in-python/" rel="alternate"></link><published>2021-09-07T00:00:00+02:00</published><updated>2022-04-13T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-07:/how-to-read-directory-content-in-python/</id><summary type="html">&lt;p&gt;We look at three ways to read directory content using the built-in os module.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to read directory content in Python?" src="https://michaeliscoding.com/images/0011-read-directory-content-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Reading directory content is easy in Python. The most common is to use the built-in &lt;code&gt;os&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;First, let’s start with the test directory we'll be using. It looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;my_dir
  | - file2.txt
  | - file1.txt
  | - my_subdir
     | - subdir_file2.txt
     | - subdir_file1.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt="Our sample directory" src="https://michaeliscoding.com/images/0011-sample-directory.png"&gt;&lt;/p&gt;
&lt;p&gt;With that out of the way, let’s look at the three functions we can use.&lt;/p&gt;
&lt;h2 id="oslistdir"&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;a class="headerlink" href="#oslistdir" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The simplest way to list directory content is by using  &lt;code&gt;os.listdir&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

content = os.listdir('/Users/michaeliscoding/my_dir')

# outputs: ['file2.txt', 'file1.txt', 'my_subdir']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This method will return a list of strings. Each string is the name of a file 
or directory.&lt;/p&gt;
&lt;p&gt;Sometimes, it might be enough, but it has three drawbacks:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We only have the name of the file or folder, not a path to it. The path might be useful if we want to do something with files/folders &lt;/li&gt;
&lt;li&gt;We don’t know if the item in the list is a file or a folder - we only have the name&lt;/li&gt;
&lt;li&gt;We received a list of what is in the directory only on the top level, ignoring what is in subfolders. In our case, we don’t know what is in &lt;em&gt;my_subdir&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="get-path"&gt;Get path&lt;a class="headerlink" href="#get-path" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We can fix the first drawback by using the &lt;code&gt;os.path.join()&lt;/code&gt; function. It puts together the path to our directory and file (or sub-directory) name to get the path:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

dir_path = '/Users/michaeliscoding/my_dir'
content = os.listdir(dir_path)
for item_name in content:
    item_path = os.path.join(dir_path, item_name)
    print(item_path)

# outputs: 
# /Users/michaeliscoding/my_dir/file2.txt
# /Users/michaeliscoding/my_dir/file1.txt
# /Users/michaeliscoding/my_dir/my_subdir

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="check-if-an-item-is-a-file-or-directory"&gt;Check if an item is a file or directory&lt;a class="headerlink" href="#check-if-an-item-is-a-file-or-directory" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We can use the function &lt;code&gt;os.path.isfile()&lt;/code&gt; to check if an item is a file or a directory. This function takes the path and returns &lt;code&gt;True&lt;/code&gt; if there is a file at the path. Otherwise, for a directory, it returns &lt;code&gt;False&lt;/code&gt;. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

dir_path = '/Users/michaeliscoding/my_dir'
content = os.listdir(dir_path)
for item_name in content:
    item_path = os.path.join(dir_path, item_name)
    if os.path.isfile(item_path):
        print('FILE: ' + item_path)
    else:
        print('DIR: ' + item_path)

# outputs: 
# FILE: /Users/michaeliscoding/my_dir/file2.txt
# FILE: /Users/michaeliscoding/my_dir/file1.txt
# DIR: /Users/michaeliscoding/my_dir/my_subdir

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is a matter of opinion whether the third drawback is actually a drawback. If we don’t care about sub-directories, then  &lt;code&gt;os.listdir()&lt;/code&gt; will work fine. 
Otherwise, the following function might work better for us.&lt;/p&gt;
&lt;h2 id="oswalk"&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;a class="headerlink" href="#oswalk" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Like the previous one, the &lt;code&gt;os.walk()&lt;/code&gt; function takes a directory path as a parameter. 
But it doesn't return a simple list of files/folders names in our directory.&lt;/p&gt;
&lt;p&gt;It walks our directory recursively through all the sub-directories and returns one tuple for each directory it finds on the way down.&lt;/p&gt;
&lt;p&gt;Each tuple contains three things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first is the path to the directory this tuple is describing&lt;/li&gt;
&lt;li&gt;The second item is a list of sub-directories under this directory &lt;/li&gt;
&lt;li&gt;The third is a list of files in this directory&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

dir_path = '/Users/michaeliscoding/my_dir'

for item in os.walk(dir_path):
    print(item)

# Outputs:
# ('/Users/michaeliscoding/projects/my_dir', ['my_subdir'], ['file2.txt', 'file1.txt'])
# ('/Users/michaeliscoding/projects/my_dir/my_subdir', [], ['subdir_file2.txt', 'subdir_file1.txt'])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For our &lt;em&gt;my_dir&lt;/em&gt; directory, we received two tuples. 
The first one is a tuple describing our &lt;em&gt;my_dir&lt;/em&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;('/Users/michaeliscoding/projects/my_dir', 
 ['my_subdir'], 
 ['file2.txt', 'file1.txt'])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It contains the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;'/Users/michaeliscoding/projects/my_dir'&lt;/code&gt; - This is path to our &lt;em&gt;my_dir&lt;/em&gt; directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[‘my_subdir']&lt;/code&gt; - This is list of sub-directories in our &lt;em&gt;my_dir&lt;/em&gt; directory containing one item: &lt;em&gt;my_subdir&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;['file2.txt', 'file1.txt']&lt;/code&gt; - This is list of files under &lt;em&gt;my_dir&lt;/em&gt; directory&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second one is a tuple describing our sub-directory &lt;em&gt;my_subdir&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;('/Users/michaeliscoding/projects/my_dir/my_subdir', 
 [], 
 ['subdir_file2.txt', 'subdir_file1.txt'])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It contains the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;'/Users/michaeliscoding/projects/my_dir/my_subdir'&lt;/code&gt; - This is path to &lt;em&gt;my_subdir&lt;/em&gt; directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; - This is list of sub-directories in &lt;em&gt;my_subdir&lt;/em&gt; - it doesn’t have any sub-directories so its empty&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[‘subdir_file2.txt', 'subdir_file1.txt']&lt;/code&gt; - This is list of files in &lt;em&gt;my_subdir&lt;/em&gt; directory&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As we can see from the above, &lt;code&gt;os.walk()&lt;/code&gt; walks through the directory and all its subdirectories recursively. So we will get the entire tree of the directory.&lt;/p&gt;
&lt;p&gt;With these tuples, we know what is what. Tuples are generated only for directories. The first item in the tuple is a path to the directory. Then the second item in the tuple always contains a list of sub-directories.
Files are always in the third item of the tuple.&lt;/p&gt;
&lt;p&gt;We still need to put together the path by joining the path of the directory, which is in the first item with a file name or a directory name:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# we iterate through all tuples
for item in os.walk(dir_path):
    # second item - list of sub-directories - has index 1
    # we iterate through all sub-directories
    for subdir_name in item[1]:
        # first item - path to directory this tuple describes - has index 0 
        subdir_path = os.path.join(item[0], subdir_name)
        print('DIR: ' + subdir_path)
    # third item - list of files - has index 2
    # we iterate through all files 
    for file_name in item[2]:
        file_path = os.path.join(item[0], file_name)
        print('FILE: ' + file_path)

# outputs:
# DIR: /Users/michaeliscoding/projects/my_dir/my_subdir
# FILE: /Users/michaeliscoding/projects/my_dir/file2.txt
# FILE: /Users/michaeliscoding/projects/my_dir/file1.txt
# FILE: /Users/michaeliscoding/projects/my_dir/my_subdir/subdir_file2.txt
# FILE: /Users/michaeliscoding/projects/my_dir/my_subdir/subdir_file1.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="osscandir"&gt;&lt;code&gt;os.scandir()&lt;/code&gt;&lt;a class="headerlink" href="#osscandir" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Another function we can use to list the content of a directory is &lt;code&gt;os.scandir()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It works similarly to &lt;code&gt;os.listdir()&lt;/code&gt;, taking the path to the directory as a parameter, except it doesn't return just names of files and sub-directories. &lt;/p&gt;
&lt;p&gt;Instead, it returns &lt;code&gt;os.DirEntry&lt;/code&gt; objects which have some useful properties and methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt; property - returns name of the file/directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;path&lt;/code&gt; property - return path to the file/directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_file()&lt;/code&gt; method - returns True for file; otherwise False&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_dir()&lt;/code&gt; method - returns True for directory; otherwise False&lt;/li&gt;
&lt;li&gt;few more which we can read about in the &lt;a href="https://docs.python.org/3/library/os.html#os.DirEntry"&gt;documentation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using &lt;code&gt;os.scandir()&lt;/code&gt;, our code would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os

dir_path = '/Users/michaeliscoding/my_dir'
content = os.scandir(dir_path)
for item in content:
    if item.is_file():
        print('FILE: ' + item.path)
    else:
        print('DIR: ' + item.path)

# outputs:
# FILE: /Users/michaeliscoding/projects/my_dir/file2.txt
# FILE: /Users/michaeliscoding/projects/my_dir/file1.txt
# DIR: /Users/michaeliscoding/projects/my_dir/my_subdir
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We went through 3 simple ways to list directory content using the built-in &lt;code&gt;os&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;There is no best one here, really. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;os.listdir()&lt;/code&gt;is the simplest, but we need to do extra things to get the path or type (file/dir).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.walk()&lt;/code&gt; is the only one that reads the complete directory tree, including sub-directories.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;os.scandir()&lt;/code&gt; is as simple as &lt;code&gt;listdir()&lt;/code&gt;, but we get back objects instead of strings, so it's easier to get type (file/dir).&lt;/li&gt;
&lt;/ul&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="directory"></category><category term="os"></category><category term="file"></category><category term="listdir()"></category><category term="walk()"></category><category term="scandir()"></category></entry><entry><title>About bool in Python</title><link href="https://michaeliscoding.com/about-bool-in-python/" rel="alternate"></link><published>2021-09-02T00:00:00+02:00</published><updated>2022-04-13T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-09-02:/about-bool-in-python/</id><summary type="html">&lt;p&gt;True+1+True=3. What bool values really are in Python.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="About bool in Python" src="https://michaeliscoding.com/images/0010-about-bool-python.jpg"&gt;&lt;/p&gt;
&lt;h2 id="true-1-true-3"&gt;&lt;code&gt;True + 1 + True = 3&lt;/code&gt;&lt;a class="headerlink" href="#true-1-true-3" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Try this in Python's REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;True + 1 + True
# outputs: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What?! Yeah, it's surprising. &lt;/p&gt;
&lt;p&gt;Bool values - &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; - can be used as numbers in Python. &lt;code&gt;True&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So we can do funny things like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;5 * False
# outputs: 0

sum([True, True, True, True, True])
# outputs: 5

True + 1 + False *10
# outputs: 2

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ok. I'm sure you get the point. &lt;/p&gt;
&lt;h2 id="why-is-that"&gt;Why is that?&lt;a class="headerlink" href="#why-is-that" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;What if we ask for a type of True or False?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;type(True)
# outputs: &amp;lt;class 'bool'&amp;gt;

type(False)
# outputs: &amp;lt;class 'bool'&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that values True and False are of the type of the class &lt;code&gt;bool&lt;/code&gt;. So why does it work like numbers too?&lt;/p&gt;
&lt;p&gt;It is because class &lt;code&gt;bool&lt;/code&gt; inherits from class &lt;code&gt;int&lt;/code&gt;. The following code is in Python's source code:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class bool(int):
    &amp;quot;&amp;quot;&amp;quot;
    bool(x) -&amp;gt; bool

    Returns True when the argument x is true, False otherwise.
    The builtins True and False are the only two instances of the class bool.
    The class bool is a subclass of the class int, and cannot be subclassed.
    &amp;quot;&amp;quot;&amp;quot;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So bool values are backed by numbers in Python. It doesn't cause any problems most of the time, but sometimes we need to be careful.  &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;x = True
isinstance(x, int)
# outputs: True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code, we assign True to variable x. Then we check if &lt;code&gt;x&lt;/code&gt; is an instance of class &lt;code&gt;int&lt;/code&gt;. And it returns &lt;code&gt;True&lt;/code&gt;. We already know that it is 
because &lt;code&gt;bool&lt;/code&gt; inherits from &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So any code that expects &lt;code&gt;int&lt;/code&gt; will also work if it receives &lt;code&gt;bool&lt;/code&gt; values 
instead.&lt;/p&gt;
&lt;p&gt;By work, I mean it will not crash. But will it do what the user of that code is expecting? Possibly not, because bool values have a different purpose than int (number) values.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt; are keywords in Python 3. &lt;code&gt;True&lt;/code&gt; is always &lt;code&gt;1&lt;/code&gt;, and &lt;code&gt;False&lt;/code&gt; is always &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;int(True)
# outputs 1
int(False)
# outputs 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also turn any int to bool:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;bool(1)
# outputs True

bool(7)
# outputs True

bool(-8)
# outputs True

bool(0)
# outputs False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bool(number)&lt;/code&gt; will output &lt;code&gt;True&lt;/code&gt; for any number except 0. Keep this in mind. Every &lt;code&gt;int&lt;/code&gt; number is &lt;code&gt;True&lt;/code&gt; except for &lt;code&gt;0&lt;/code&gt;, which is &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;</content><category term="Python explained"></category><category term="python"></category><category term="bool"></category><category term="True"></category><category term="False"></category><category term="int"></category><category term="numbers"></category></entry><entry><title>Difference between sorted() and .sort() in Python</title><link href="https://michaeliscoding.com/difference-between-sort-and-sorted-in-python/" rel="alternate"></link><published>2021-08-31T00:00:00+02:00</published><updated>2022-04-13T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-31:/difference-between-sort-and-sorted-in-python/</id><summary type="html">&lt;p&gt;Why is the sort() used like my_list.sort() but sorted() is used as sorted(my_list)? What is the key difference between them?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Difference between sorted() and .sort() in Python" src="https://michaeliscoding.com/images/0009-difference-between-sort-and-sorted-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Why is the &lt;code&gt;sort()&lt;/code&gt; used like &lt;code&gt;my_list.sort()&lt;/code&gt; but &lt;code&gt;sorted()&lt;/code&gt; is used as &lt;code&gt;sorted(my_list)&lt;/code&gt;? What is the key difference between them?&lt;/p&gt;
&lt;h2 id="the-key-difference"&gt;The key difference&lt;a class="headerlink" href="#the-key-difference" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The most significant difference is the following:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sorted()&lt;/code&gt; is a function that reads an existing list (passed in as a parameter) and creates a new list with the same values as the original list but sorted. It leaves the original list untouched.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sort()&lt;/code&gt; is a method called on a list and modifies that list by ordering its items. It doesn't return anything. &lt;/p&gt;
&lt;p&gt;Let's look more closely at each.&lt;/p&gt;
&lt;h2 id="sort"&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;a class="headerlink" href="#sort" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sort()&lt;/code&gt; is a method available only on &lt;code&gt;list&lt;/code&gt; objects. It sorts the list we call it on. That means it modifies the list itself.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;original = [8, 6, 4, 2]

original.sort()

print(original)
# outputs: [2, 4, 6, 8]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="sorted"&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;a class="headerlink" href="#sorted" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sorted()&lt;/code&gt; is a function.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It takes any iterable as a parameter, not just a list. That means we can give it a tuple or dictionary etc.&lt;/li&gt;
&lt;li&gt;It doesn't modify the list (or iterable) we give it. It leaves the original list (iterable) untouched.&lt;/li&gt;
&lt;li&gt;It creates a new list that contains the same values as the original list (iterable) but ordered. It always returns a list regardless of the iterable we give it.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;original = [8, 6, 4, 2]

ordered = sorted(original)

print(ordered)
# outputs: [2, 4, 6, 8]

print(original)
# outputs: [8, 6, 4, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below are a few samples of how &lt;code&gt;sorted()&lt;/code&gt; works with other iterables.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;ordered_from_tuple = sorted((4, 3, 2, 1))
print(ordered_from_tuple)

# outputs: [1, 2, 3, 4]

ordered_from_set = sorted({4, 3, 2, 1})
print(ordered_from_tuple)
# outputs: [1, 2, 3, 4]

my_dict = {1: 'a', 2: 'b', 3:'c', 4:'d'}
ordered_from_dict = sorted(my_dict)
print(ordered_from_dict)
# outputs: [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, when we give &lt;code&gt;sorted()&lt;/code&gt; a dict, it just takes the keys and returns them ordered in a list. It completely ignores values.&lt;/p&gt;</content><category term="Python explained"></category><category term="python"></category><category term="sort"></category><category term="sorted"></category><category term="list"></category><category term="sorting"></category><category term="iterable"></category></entry><entry><title>Python's in operator</title><link href="https://michaeliscoding.com/python-in-operator/" rel="alternate"></link><published>2021-08-26T00:00:00+02:00</published><updated>2022-04-12T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-26:/python-in-operator/</id><summary type="html">&lt;p&gt;Where and how do we use the &lt;strong&gt;&lt;code&gt;in&lt;/code&gt;&lt;/strong&gt; operator in Python.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Python's in operator" src="https://michaeliscoding.com/images/0008-python-in-operator.jpg"&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; operator is ubiquitous in Python; it is used with strings, lists and other iterables to check if they contain a specific element.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;in&lt;/code&gt; is a binary membership operator.&lt;/p&gt;
&lt;p&gt;Binary means it uses two operands—one on the left and one on the right.&lt;/p&gt;
&lt;p&gt;&lt;img alt="in operands" src="https://michaeliscoding.com/images/0008-in-operands-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Membership means it checks if one operand is a member of the other operand. The &lt;em&gt;in&lt;/em&gt; operator checks if its left operand is a member of its left operand. &lt;/p&gt;
&lt;p&gt;Or, put more simply, it checks if its right operand contains its left operand. If it does, it returns &lt;code&gt;True&lt;/code&gt;;  otherwise, it returns &lt;code&gt;False&lt;/code&gt;. 
We can use it only if an operand on the right is iterable.&lt;/p&gt;
&lt;p&gt;Both left and right operands can be variables or values (constants).&lt;/p&gt;
&lt;p&gt;Let's look at how we use it with different objects in Python.&lt;/p&gt;
&lt;h2 id="strings"&gt;Strings&lt;a class="headerlink" href="#strings" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; operator can check if the string on the right contains the string on the left.
In other words, we can use it to check if a string contains some substring.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;s = 'Big blue sky'

'blue' in s
# outputs: True

b = 'blue'

b in s
# outputs: True

'red' in s
# outputs: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; operator is  case-sensitive:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;'big' in s
# outputs: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'Big blue sky'&lt;/code&gt; does not contain &lt;code&gt;big&lt;/code&gt;, but it does contain &lt;code&gt;Big&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Few more examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;j = 'joy of coding'

'din' in j
# outputs: True

'y of' in j
# outputs: True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="lists-and-other-iterables"&gt;Lists and other iterables&lt;a class="headerlink" href="#lists-and-other-iterables" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; operator also works with any iterable - lists, tuples, sets and others.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [2, 4, 6, 8]

4 in numbers
# outputs: True

5 in numbers
# outputs: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tuples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;t = ('a', 'b', 'c')

'a' in t
# outputs: True

'f' in t
# outputs: False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Sets:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;colors = {'red', 'green', 'blue'}

'gr' in colors
# outputs: False

'red' in colors
# outputs: True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Please note that when we work with lists, sets, tuples (and dicts), the &lt;code&gt;in&lt;/code&gt; operator checks if its left operand is an exact match to any item in the right operand.
Unlike when we use the &lt;code&gt;in&lt;/code&gt; with two strings, it is not looking for a substring.&lt;/p&gt;
&lt;h2 id="dicts"&gt;Dicts&lt;a class="headerlink" href="#dicts" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;dict&lt;/em&gt; is also iterable, but when we use the &lt;code&gt;in&lt;/code&gt; operator with a dict, it only uses the dict's keys to check for membership.&lt;/p&gt;
&lt;p&gt;It ignores the dict's values.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fruits = {
    'apple': 'red',
    'banana': 'yellow',
    'lime': 'green'
}

'red' in fruits
# outputs: False

'banana' in fruits
# outputs: True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the &lt;code&gt;in&lt;/code&gt; operator for dicts means: "Does the dict contains this key?"&lt;/p&gt;
&lt;h2 id="not-in"&gt;&lt;code&gt;not in&lt;/code&gt;&lt;a class="headerlink" href="#not-in" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;in&lt;/code&gt; operator returns &lt;code&gt;True&lt;/code&gt; if the left operand is a member of the right operand. 
&lt;code&gt;not in&lt;/code&gt; does the exact opposite. It returns &lt;code&gt;True&lt;/code&gt; if the left operand is NOT a member of the right operand.&lt;/p&gt;
&lt;p&gt;Few examples:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;s = 'Big blue sky'

'yellow' not in s
# outputs: True

'blue' not in s
# outputs: False

numbers = [2, 4, 6, 8]

1 not in numbers
# outputs True

2 not in numbers
# outputs False

fruits = {
    'apple': 'red',
    'banana': 'yellow',
    'lime': 'green'
}

'red' not in fruits
# outputs: True

'banana' not in fruits
# outputs: False
&lt;/code&gt;&lt;/pre&gt;</content><category term="Python reference"></category><category term="python"></category><category term="in"></category><category term="list"></category><category term="string"></category><category term="operator"></category></entry><entry><title>How to filter a list in Python</title><link href="https://michaeliscoding.com/how-to-filter-list-in-python/" rel="alternate"></link><published>2021-08-24T00:00:00+02:00</published><updated>2022-04-12T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-24:/how-to-filter-list-in-python/</id><summary type="html">&lt;p&gt;There are many ways to filter a list in Python. What are they and which one is the best?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to filter list in Python" src="https://michaeliscoding.com/images/0007-filter-list-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Filtering a list (or array) is a common thing every programmer needs to do quite often.&lt;/p&gt;
&lt;p&gt;There are many ways to filter a list in Python. What are they, and which one is the best?&lt;/p&gt;
&lt;h2 id="setup"&gt;Setup&lt;a class="headerlink" href="#setup" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We start with a list of fruits like the one below:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fruits = [
    'apple',
    'pear',
    'strawberry',
    'orange',
    'blueberry',
    'lemon',
    'raspberry',
    'cranberry'
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to filter this list, so the new list contains only berries (strawberry, blueberry, raspberry and cranberry).&lt;/p&gt;
&lt;p&gt;To determine if a fruit is a berry, we'll check if it contains the string &lt;em&gt;'berry'&lt;/em&gt;. It might be a naive condition but good enough for our purpose here. We'll use the &lt;code&gt;in&lt;/code&gt; operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;'berry' in fruit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="using-a-for-loop"&gt;Using a &lt;em&gt;for&lt;/em&gt; loop&lt;a class="headerlink" href="#using-a-for-loop" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Let's start with a plain old &lt;em&gt;for&lt;/em&gt; loop. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;berries = []

for fruit in fruits:
    if 'berry' in fruit:
        berries.append(fruit)

print(berries)
# will output
# ['strawberry', 'blueberry', 'raspberry', 'cranberry']
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We create an empty list named &lt;code&gt;berries&lt;/code&gt;. Then we go through every item in &lt;code&gt;fruits&lt;/code&gt; to check if it contains &lt;em&gt;'berry'&lt;/em&gt; and if so, we add it to our new list &lt;code&gt;berries&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The code above is probably the most common solution. &lt;/p&gt;
&lt;h2 id="using-a-list-comprehension"&gt;Using a list comprehension&lt;a class="headerlink" href="#using-a-list-comprehension" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python is a very expressive and succinct language, and list comprehensions are one of its most remarkable features.&lt;/p&gt;
&lt;p&gt;We can use it to do filtering:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;berries = [fruit for fruit in fruits if 'berry' in fruit]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code is very nice and short. And very pythonic. &lt;/p&gt;
&lt;p&gt;List comprehensions allow us to add an &lt;code&gt;if&lt;/code&gt; statement, and we can use this to build a new filtered list. &lt;/p&gt;
&lt;p&gt;The comprehension above will add the &lt;code&gt;fruit&lt;/code&gt; to the new list only when the &lt;code&gt;if&lt;/code&gt; condition evaluates to &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="using-the-built-in-filter-function"&gt;Using the built-in &lt;code&gt;filter()&lt;/code&gt; function&lt;a class="headerlink" href="#using-the-built-in-filter-function" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python has a built-in function &lt;code&gt;filter()&lt;/code&gt;, which we use for ... &lt;/p&gt;
&lt;p&gt;wait for it...&lt;/p&gt;
&lt;p&gt;filtering. &lt;/p&gt;
&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt; takes 2 parameters: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The first parameter is a function that determines if an item should be filtered out or not. It receives each item as a parameter and should return True for items we want to keep; otherwise, it should return False.&lt;/li&gt;
&lt;li&gt;The second parameter is a list (or other iterable) that we want to filter.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def is_berry(fruit):
    return 'berry' in fruit

berries = filter(is_berry, fruits)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or we can use it with &lt;code&gt;lambda&lt;/code&gt; if our condition is simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;berries = filter(lambda fruit: 'berry' in fruit, fruits)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But there is a slight problem here. &lt;/p&gt;
&lt;p&gt;In both cases above, &lt;code&gt;filter()&lt;/code&gt; actually doesn't return a list but rather a &lt;code&gt;filter object&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;The filter object is an iterator - very helpful if we operate on large datasets as it doesn't load data in the memory all at once.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;print(berries)
# will output
# &amp;lt;filter object at 0x10314b610&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Often we can use an iterator exactly like a list (but only once). But if we want an actual list, we need to create it explicitly from the iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;berries =  list(filter(lambda fruit: 'berry' in fruit, fruits))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="using-a-generator-expression"&gt;Using a generator expression&lt;a class="headerlink" href="#using-a-generator-expression" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Generator expression works like comprehension, except it returns a generator object rather than a list. &lt;/p&gt;
&lt;p&gt;A generator object is an iterator which might be helpful if we work with large datasets.&lt;/p&gt;
&lt;p&gt;We write generator expression same as a list comprehension except we change square brackets &lt;code&gt;[]&lt;/code&gt; to round brackets &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;berries = (fruit for fruit in fruits if 'berry' in fruit)
print(berries)
# will output
# &amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x102f43300&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="what-option-is-the-best"&gt;What option is the best?&lt;a class="headerlink" href="#what-option-is-the-best" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If we need an actual list and our dataset is not too big, the best option is to use list comprehension. 
It's very pythonic and short. Most Python programmers will understand it straight away.&lt;/p&gt;
&lt;p&gt;We should use the filter() or generator expression when working with a large dataset.
&lt;code&gt;filter()&lt;/code&gt; is more verbose unless our function, which determines if an item should be filtered out, already exists. But we can still use &lt;code&gt;lambda&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Plain old for loop is the most lengthy, but one benefit is that it will be 
also understood by people who don't know Python.&lt;/p&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="comprehension"></category><category term="list"></category><category term="filter"></category><category term="lambda"></category></entry><entry><title>How to get the first matching item in a list without a loop in Python</title><link href="https://michaeliscoding.com/how-to-get-first-matching-item-without-loop-in-python/" rel="alternate"></link><published>2021-08-19T00:00:00+02:00</published><updated>2022-04-11T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-19:/how-to-get-first-matching-item-without-loop-in-python/</id><summary type="html">&lt;p&gt;Can we avoid a loop and keep its efficiency when we want to get the first matching item in the list?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to get the first matching item in a list without a loop in Python" src="https://michaeliscoding.com/images/0006-first-matching-item-without-loop-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;In programming, it is very common that we need to get the first item from a list that matches some criteria. Let's look at our options in Python and if we can do it without a &lt;em&gt;for&lt;/em&gt; loop.&lt;/p&gt;
&lt;p&gt;Say we have defined class Fruit:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@dataclass(frozen=True)
class Fruit:
    name: str
    color: str
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we have a list of fruits like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;fruits = [
    Fruit('apple', 'red'),
    Fruit('orange', 'orange'),
    Fruit('lemon', 'yellow'),
    Fruit('lime', 'green'),
    Fruit('banana', 'yellow'),
    Fruit('plum', 'blue'),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We want to get the first fruit from the list with a yellow colour.&lt;/p&gt;
&lt;h2 id="using-a-for-loop"&gt;Using a &lt;em&gt;for&lt;/em&gt; loop&lt;a class="headerlink" href="#using-a-for-loop" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The simplest way to do this is to iterate through the items in the list, 
check the colour, and if it's yellow, return the item. &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;
def get_first_yellow(list_of_fruits):
    for f in list_of_fruits:
        if f.color == 'yellow':
            return f
    return None


get_yellow(fruits)

# will return 
# Fruit(name='lemon', color='yellow')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This code is very efficient as we terminate the loop (and the function) on the 
the first match, so we don't do any unnecessary work. &lt;/p&gt;
&lt;p&gt;If there is no yellow fruit loop, we return &lt;code&gt;None&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="can-we-do-this-without-a-loop"&gt;Can we do this without a loop?&lt;a class="headerlink" href="#can-we-do-this-without-a-loop" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can avoid the loop by using list comprehension.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_first_yellow_no_loop(list_of_fruits):
    matches = [f for f in list_of_fruits if f.color == 'yellow']
    if matches:
        return matches[0]
    return None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this also works, have we gained anything? &lt;/p&gt;
&lt;p&gt;The code is not shorter. &lt;/p&gt;
&lt;p&gt;It is not clearer. &lt;/p&gt;
&lt;p&gt;And, it's also less efficient because:
- it will go through the whole list (not only until it finds the first match)
- create a new list of matching items
- do &lt;em&gt;if&lt;/em&gt; and only then return&lt;/p&gt;
&lt;p&gt;Loop was better.&lt;/p&gt;
&lt;p&gt;Can we do this without the loop with the same efficiency?&lt;/p&gt;
&lt;h2 id="generator-expression-and-the-next-function"&gt;Generator expression and the &lt;code&gt;next()&lt;/code&gt; function&lt;a class="headerlink" href="#generator-expression-and-the-next-function" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We could use a generator expression to avoid iterating through the whole list.&lt;/p&gt;
&lt;p&gt;The generator doesn't create a new list. It outputs values on the fly when we need them.&lt;/p&gt;
&lt;p&gt;We can rewrite our function with a generator expression like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_first_yellow_generator(list_of_fruits):
    matches = (f for f in list_of_fruits if f.color == 'yellow')
    return next(matches, None)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we created a generator with generator expression and assigned it to
variable matches.&lt;/p&gt;
&lt;p&gt;Then, we used the built-in function &lt;a href="https://docs.python.org/3/library/functions.html#next"&gt;&lt;code&gt;next()&lt;/code&gt;&lt;/a&gt;, which retrieves the next item from our &lt;code&gt;matches&lt;/code&gt; generator. &lt;/p&gt;
&lt;p&gt;The second parameter to the &lt;code&gt;next()&lt;/code&gt; is the value to return if there is no next item. 
If we don't provide this value, then the &lt;code&gt;next()&lt;/code&gt; would throw a &lt;code&gt;StopIteration&lt;/code&gt; exception if there are no yellow items in our list.&lt;/p&gt;
&lt;p&gt;This code is very efficient because it doesn't iterate the whole list or allocate any memory for a new list. &lt;/p&gt;
&lt;p&gt;It's also clear what's going on to any experienced Python developer.
We can also make it one line if you're into one-liners.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def get_first_yellow_one_line(list_of_fruits):
    return next((f for f in list_of_fruits if f.color == 'yellow'), None)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are multiple ways to get the first matching item from a list (or any iterable).&lt;/p&gt;
&lt;p&gt;There is nothing wrong with a &lt;em&gt;for&lt;/em&gt; loop here. We're not mutating any variables, and it's very efficient.&lt;/p&gt;
&lt;p&gt;As we can see, replacing the &lt;em&gt;for&lt;/em&gt; loop with a comprehension doesn't help us at all, so I don't recommend that (unless we use the filtered list for some further processing).&lt;/p&gt;
&lt;p&gt;We can avoid the &lt;em&gt;for&lt;/em&gt; loop and keep clarity and efficiency by using generator expression. &lt;/p&gt;
&lt;p&gt;This code will be shorter and might be preferred by more experienced
Python developers but will be a bit harder to understand for people just 
starting with Python.&lt;/p&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="comprehension"></category><category term="list"></category><category term="generator"></category><category term="loop"></category><category term="next()"></category></entry><entry><title>How to flat a list of lists in Python</title><link href="https://michaeliscoding.com/how-to-flat-list-of-lists-in-python/" rel="alternate"></link><published>2021-08-17T00:00:00+02:00</published><updated>2022-04-11T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-17:/how-to-flat-list-of-lists-in-python/</id><summary type="html">&lt;p&gt;What is the best way to flat a list of lists?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to flat a list of lists in Python" src="https://michaeliscoding.com/images/0005-flat-list-of-lists-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Let's say we have a list of lists like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;list_of_lists = [
    ['London', 'Manchester'],
    ['New York', 'Los Angeles'],
    ['Rome', 'Milan']
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What's the best way to turn it into a simple list that looks like this?&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;['London', 'Manchester', 'New York', 'Los Angeles', 'Rome', 'Milan']
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="using-a-for-loop"&gt;Using a &lt;em&gt;for&lt;/em&gt; loop&lt;a class="headerlink" href="#using-a-for-loop" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Using &lt;em&gt;for&lt;/em&gt; loop, we can flat list of lists in two ways.&lt;/p&gt;
&lt;p&gt;The first one is to use the inner &lt;em&gt;for&lt;/em&gt; loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;flat = []
for sublist in list_of_lists:
    for item in sublist:
        flat.append(item)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the four lines of code above we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an empty list. &lt;/li&gt;
&lt;li&gt;Iterate through list_of_lists.&lt;/li&gt;
&lt;li&gt;Then iterate through each sublist.&lt;/li&gt;
&lt;li&gt;Then when we get to an item in the sublist, append it to our flat list.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The second one is to use only one loop.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;flat = []
for sublist in list_of_lists:
    flat.extend(sublist)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the three lines of code above we:
1. Create an empty list. 
1. Iterate through list_of_lists.
1. We extend our flat list with the content of the sublist.&lt;/p&gt;
&lt;p&gt;This second option is shorter and also faster. It's probably also a bit easier to understand.&lt;/p&gt;
&lt;p&gt;But there are better ways.&lt;/p&gt;
&lt;h2 id="using-a-list-comprehension"&gt;Using a list comprehension&lt;a class="headerlink" href="#using-a-list-comprehension" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a list comprehension, it's nice and short:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;flat = [item for sublist in list_of_lists for item in sublist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What's going on here?&lt;/p&gt;
&lt;p&gt;It is pretty similar to the inner &lt;code&gt;for&lt;/code&gt; loop. &lt;/p&gt;
&lt;p&gt;Let's reformat that comprehension to see the similarity:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;flat = [item 
        for sublist in list_of_lists 
            for item in sublist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see it's the same two &lt;em&gt;for&lt;/em&gt; loops when formatted like this.  &lt;/p&gt;
&lt;p&gt;The only difference is that instead of &lt;code&gt;flat.append(item)&lt;/code&gt; in the inner loop, we use &lt;code&gt;item&lt;/code&gt; at the beginning of the comprehension. &lt;/p&gt;
&lt;h2 id="using-the-itertools"&gt;Using the &lt;em&gt;itertools&lt;/em&gt;&lt;a class="headerlink" href="#using-the-itertools" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For completeness, I want to mention we can use &lt;a href="https://docs.python.org/3/library/itertools.html"&gt;itertools&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;We could use two functions: &lt;code&gt;chain&lt;/code&gt; and &lt;code&gt;chain_iterable&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from itertools import chain

# Using chain, please note * before list_of_lists
flat1 = chain(*list_of_lists)

# Using chain_iterable
flat2 = chain.from_iterable(list_of_lists)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These functions, however, don't return a list but rather an iterator, so if we need a list, we need to create it explicitly.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;flat_list_1 = list(chain(*list_of_lists))

flat_list_2 = list(chain.from_iterable(list_of_lists))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I recommend using list comprehension. &lt;/p&gt;
&lt;p&gt;It's one line, it doesn't mutate any variable, it is clear to any experienced Python developer, and it's also the fastest.&lt;/p&gt;
&lt;p&gt;Also, if we need to apply some function to an &lt;code&gt;item&lt;/code&gt;, we can do it directly as part of comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;# Notice item.lower()
flat = [item.lower() for sublist in list_of_lists for item in sublist]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In case we don't want to allocate a list, we can also turn it into a generator expression by changing brackets from &lt;code&gt;[]&lt;/code&gt; to &lt;code&gt;()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;flat = (item.lower() for sublist in list_of_lists for item in sublist)
&lt;/code&gt;&lt;/pre&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="comprehension"></category><category term="list"></category><category term="for loop"></category></entry><entry><title>How to merge dictionaries in Python</title><link href="https://michaeliscoding.com/how-to-merge-dictionaries-in-python/" rel="alternate"></link><published>2021-08-12T00:00:00+02:00</published><updated>2022-04-08T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-12:/how-to-merge-dictionaries-in-python/</id><summary type="html">&lt;p&gt;What is the best way to merge two or more dictionaries into one?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to merge dictionaries in Python" src="https://michaeliscoding.com/images/0004-merge-dictionaries-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;We have two dictionaries, &lt;code&gt;d1&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, and we want to merge them, so we end up with a dictionary containing values from both.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;d1 = {'left': 5, 'right': 10}

d2 = {'top': 15, 'bottom': 20}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The expected result after merging is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;{'left': 5, 'right': 10, 'top': 15, 'bottom': 20}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="using-the-dictionary-union"&gt;Using the dictionary union&lt;a class="headerlink" href="#using-the-dictionary-union" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The cleanest and shortest way is to use dictionary union. It is available &lt;strong&gt;only for Python 3.9&lt;/strong&gt; and newer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;merged = d1 | d2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="using-the-dictionary-constructor"&gt;Using the dictionary constructor&lt;a class="headerlink" href="#using-the-dictionary-constructor" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The second best way is to use a dictionary constructor. It is available &lt;strong&gt;for Python 3.5&lt;/strong&gt; and newer:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;merged = {**d1, **d2}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="using-a-comprehension"&gt;Using a comprehension&lt;a class="headerlink" href="#using-a-comprehension" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With Python 3.4 and lower, we'll have to write more code. The shortest and fastest option is to use a dict comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;merged = {k: v for d in [d1, d2] for k, v in d.items()}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="copy-and-update"&gt;Copy and update&lt;a class="headerlink" href="#copy-and-update" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We could also use the old-style imperative way, copy the first dict and update it with the second one. It is two lines, though, and we mutate a variable, which I do not recommend.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;merged = d1.copy()
merged.update(d2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="more-than-2-dictionaries"&gt;More than 2 dictionaries&lt;a class="headerlink" href="#more-than-2-dictionaries" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Anything above also works with three or more dictionaries, of course:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;d1 = {'left': 5, 'right': 10}

d2 = {'top': 15, 'bottom': 20}

d3 = {'height': 30, 'width': 40}

# Python 3.9+
merged = d1 | d2 | d3

# Python 3.5+
merged = {**d1, **d2, **d3}

# Python 3.4 and lower
merged = {k: v for d in [d1, d2, d3] for k, v in d.items()}

# imperative way 
merged = d1.copy()
merged.update(d2)
merged.update(d3)

# All code above will produce 
{'left': 5, 'right': 10, 'top': 15, 'bottom': 20, 'height': 30, 'width': 40}
&lt;/code&gt;&lt;/pre&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="comprehensions"></category><category term="dict"></category><category term="dictionary"></category></entry><entry><title>How to create a list of unique items with a comprehension in Python</title><link href="https://michaeliscoding.com/how-to-create-a-list-of-unique-items-with-a-comprehension-in-python/" rel="alternate"></link><published>2021-08-10T00:00:00+02:00</published><updated>2022-04-07T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-10:/how-to-create-a-list-of-unique-items-with-a-comprehension-in-python/</id><summary type="html">&lt;p&gt;List comprehensions are a fantastic tool to work with lists. Is it possible to create a list of unique items with list comprehension?&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="How to create a list of unique items with a comprehension in Python" src="https://michaeliscoding.com/images/0003-list-comprehension-unique-items-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;A list comprehension is a fantastic tool for creating lists. But is it possible to create a list of unique items with list comprehension?&lt;/p&gt;
&lt;h2 id="the-challenge"&gt;The challenge&lt;a class="headerlink" href="#the-challenge" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Let's say we have a list of posts:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;@dataclass(frozen=True)
class Post:
    title: str
    category: str

posts = [
    Post(title='first post', category='python'),
    Post(title='second post', category='python'),
    Post(title='third post', category='django'),
    Post(title='fourth post', category='python'),
    Post(title='fifth post', category='django'),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now say we want to get a list of all categories, but we don't want any category to appear twice in our list. So the resulting list from the above &lt;code&gt;posts&lt;/code&gt; list would be &lt;code&gt;['pyton', 'django']&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With for loop, we could do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;categories = []
for p in posts:
    if p.category not in categories:
        categories.append(p.category)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="comprehension"&gt;Comprehension&lt;a class="headerlink" href="#comprehension" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;How do we achieve the same result with a list comprehension?&lt;/p&gt;
&lt;p&gt;We could try this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;categories = [p.category for p in posts if p.category not in categories]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But this will not work because the &lt;code&gt;categories&lt;/code&gt; variable doesn't exist yet. When we use comprehension, it creates a list on the fly, and we don't have it in a variable until comprehension finishes.&lt;/p&gt;
&lt;p&gt;We can use set comprehension instead. Set is a data container that contains unique values, so it will deal with uniqueness for us. To change a list comprehension to a set comprehension, the only thing We need to do is to change square brackets to curly brackets:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;categories = {p.category for p in posts}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now &lt;code&gt;categories&lt;/code&gt; is a set. That works fine if we need any iterable. But, if 
we specifically need a list we need to create a list out of a set:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;categories = list({p.category for p in posts})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's it. We did it with one line.&lt;/p&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="comprehensions"></category><category term="list comprehension"></category><category term="list"></category></entry><entry><title>When to make a new .py file for a Python project?</title><link href="https://michaeliscoding.com/when-to-make-a-new-py-file-for-a-python-project/" rel="alternate"></link><published>2021-08-06T00:00:00+02:00</published><updated>2022-04-06T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-06:/when-to-make-a-new-py-file-for-a-python-project/</id><summary type="html">&lt;p&gt;Learn when to make a new .py file for a Python project and how to split and organize code.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="When to make a new .py file for a Python project?" src="https://michaeliscoding.com/images/0002-when-new-file-for-python-project.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Most Python projects have multiple python files instead of having all code in one file. &lt;/p&gt;
&lt;p&gt;Should we always try to separate code into multiple files?&lt;/p&gt;
&lt;p&gt;How do we know when to start splitting our code into multiple files?&lt;/p&gt;
&lt;h2 id="always-split"&gt;Always split?&lt;a class="headerlink" href="#always-split" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Should we always split code into multiple files? &lt;/p&gt;
&lt;p&gt;Not always. Many Python projects are just simple scripts that do one thing and are just a few tens of lines of code. In this case, there is not much point.&lt;/p&gt;
&lt;h2 id="when-should-we-split"&gt;When should we split?&lt;a class="headerlink" href="#when-should-we-split" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If our file gets bigger, however, having more than a few hundred lines of code, it’s time to split.&lt;/p&gt;
&lt;p&gt;Why few hundreds? It’s the observation from years of experience. It’s not a very precise number, it could be 200, or it could be 900. That’s a big difference. Sometimes it can be over 1000; sometimes, it’s best to have less than 100 lines in one file.&lt;/p&gt;
&lt;p&gt;The goal here is to organise a project so that it is easy to navigate and understand.&lt;/p&gt;
&lt;p&gt;Big files are hard to navigate. Scrolling through 5000 lines of code is not very practical. &lt;/p&gt;
&lt;p&gt;Also, when many people work on a project and they use Git, it will make
things even harder if everything is in one or a few very big files.&lt;/p&gt;
&lt;p&gt;On the other hand, having a lot of very small files also makes it hard to navigate the project because we’ll have to switch between files often and lose track of what’s going on quickly.&lt;/p&gt;
&lt;h2 id="how-to-split"&gt;How to split?&lt;a class="headerlink" href="#how-to-split" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The best way is to split our code into files based on WHAT it does.&lt;/p&gt;
&lt;p&gt;Say our big app imports some data about companies  - invoices, employees, customers - does some processing and then generates a report. &lt;/p&gt;
&lt;p&gt;We could start with the following files: &lt;em&gt;import.py&lt;/em&gt;, &lt;em&gt;process.py&lt;/em&gt;, &lt;em&gt;report.py&lt;/em&gt;. &lt;/p&gt;
&lt;p&gt;When the &lt;em&gt;process.py&lt;/em&gt; file turns out to be a lot of code (more than a few hundred lines), it’s time to split it further based on different parts of your processing, e.g. &lt;em&gt;process_invoices.py&lt;/em&gt;, &lt;em&gt;process_employees.py&lt;/em&gt; and so on. &lt;/p&gt;
&lt;p&gt;Then we would probably start to organise them into folders - we’d create a process folder for all the process files. &lt;/p&gt;
&lt;p&gt;So split code logically based on what it does. That should be our primary driver for splitting.&lt;/p&gt;
&lt;p&gt;Don’t allow files to get too big, and group similar files with folders.&lt;/p&gt;
&lt;p&gt;Then, it is much easier to navigate our project, find things and use a version control system (Git).&lt;/p&gt;</content><category term="How to in Python"></category><category term="python"></category><category term="beginner"></category></entry><entry><title>Why Python</title><link href="https://michaeliscoding.com/why-python/" rel="alternate"></link><published>2021-08-04T00:00:00+02:00</published><updated>2022-04-05T00:00:00+02:00</updated><author><name>Michael</name></author><id>tag:michaeliscoding.com,2021-08-04:/why-python/</id><summary type="html">&lt;p&gt;Python is a great programming language to learn and use. We look at its benefits and why it might be the best-balanced language in beauty, usefulness and practicality.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Why Python" src="https://michaeliscoding.com/images/0001-why-python.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Whether you’ve just decided to learn programming or you're a seasoned developer starting a new project, you need to pick the programming language you'll use. &lt;/p&gt;
&lt;p&gt;This article makes a case for Python.&lt;/p&gt;
&lt;p&gt;Python is a great programming language to learn and use, and here is why.&lt;/p&gt;
&lt;h2 id="syntax"&gt;Syntax&lt;a class="headerlink" href="#syntax" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Today, most mainstream languages have C-style syntax (C, Java, JavaScript, C#, Go, etc.).&lt;/p&gt;
&lt;p&gt;While this syntax is fine and familiar, it is pretty verbose and allows programmers to go wild with the code formatting. &lt;/p&gt;
&lt;p&gt;Python took a different approach and is not using curly braces to delimit code blocks. Instead, it uses significant white spaces and code blocks are indented. We don't use a semicolon (&lt;code&gt;;&lt;/code&gt;) at the end of the line in Python.&lt;/p&gt;
&lt;p&gt;Take this function written in C-style language, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;function my_function(p1, p2) {
    if (p1 &amp;gt; p2) {
        function_a();
      }
    else {
        function_b();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also write it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;function my_function(p1, p2) {
    if (p1 &amp;gt; p2) {function_a();}
    else 
    { 
          function_b();
    function_c();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And it will do the same thing.&lt;/p&gt;
&lt;p&gt;We can write the same  function in Python like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def my_function(p1, p2):
    if p1 &amp;gt; p2:
        function_a()
    else:
        function_b()
        function_c()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if we change it like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;def my_function(p1, p2):
    if p1 &amp;gt; p2:
        function_a()
    else:
        function_b()
    function_c()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is now a different function because it will always call &lt;code&gt;function_c&lt;/code&gt;, while before, it was called only as a part of the &lt;code&gt;else&lt;/code&gt; branch. &lt;/p&gt;
&lt;p&gt;These style requirements impact the readability and maintainability of the code as programmers must style code well to make it run.&lt;/p&gt;
&lt;p&gt;Python was designed to be a highly readable language which is important because code is written once but read many times. &lt;/p&gt;
&lt;p&gt;Python is also using English words instead of punctuations for logical 
operators. For &lt;em&gt;AND&lt;/em&gt; operator, it uses the word &lt;code&gt;and&lt;/code&gt; instead of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, for &lt;em&gt;OR&lt;/em&gt;, it uses the word &lt;code&gt;or&lt;/code&gt; instead of &lt;code&gt;||&lt;/code&gt;, for &lt;em&gt;NOT&lt;/em&gt;, it uses the word &lt;code&gt;not&lt;/code&gt; instead of &lt;code&gt;!&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;In C style language:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;if (x &amp;gt; 5 &amp;amp;&amp;amp; y &amp;gt; 8 || z == 10) {
    // Do the thing
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if x &amp;gt; 5 and y &amp;gt; 8 or z == 10:
    # Do the thing
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="conciseness"&gt;Conciseness&lt;a class="headerlink" href="#conciseness" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Conciseness is partly related to syntax, which we've discussed above, but Python has excellent ways to do some things.  &lt;/p&gt;
&lt;p&gt;Python is a very concise language. &lt;/p&gt;
&lt;p&gt;It allows us to do a lot with very little code. That is important because it 
makes code easy and fast to read and write.&lt;/p&gt;
&lt;p&gt;We don't have to write a lot of code that is not directly related to what we're trying to achieve. It saves us time and mental energy.&lt;/p&gt;
&lt;p&gt;Say we want to check that the variable &lt;code&gt;number&lt;/code&gt; is bigger than &lt;code&gt;5&lt;/code&gt; and smaller than &lt;code&gt;10&lt;/code&gt;. In C style languages, we would do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;if (number &amp;gt; 5 &amp;amp;&amp;amp; number &amp;lt; 10) {
    // Do the thing
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python, we have chained comparison, and we can do this instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if 5 &amp;lt; number &amp;lt; 10:
    # Do the thing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's a similar story when we want to get part of a list (array). In Python, we can use slicing:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3 , 4, 5]

first_two = numbers[:2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While in C style languages, we would do this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;let numbers = [1, 2, 3, 4, 5];

let first_two = numbers.slice(0, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the &lt;code&gt;in&lt;/code&gt; operator, we can check if an item is in the list or other data structure. &lt;/p&gt;
&lt;p&gt;To check if a number is in the list, we would write:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;numbers = [1, 2, 3, 4, 5]

if 5 in numbers:
    # Do the thing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To check if a key is in the dictionary: &lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if 'my_key' in my_dict:
   # Do the thing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also use it to check if a string contains another string:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;if 'python' in 'Robust python':
    # Do the thing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Comprehensions are another great feature of Python making our code super concise. &lt;/p&gt;
&lt;p&gt;We can create a list, a set or a dictionary in one line. We can also map and filter with them. For example, to create a list of squares of numbers from one to ten in C style language, we would do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;let squares = [];

for (i = 1; i &amp;lt;= 10; i++) { 
    squares.push(i*i)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In Python, we can achieve the same with list comprehension:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;squares = [i * i for i in range(1, 11)]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get only squares bigger than 50, we could do this in Python:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;big = [s for s in squares if s &amp;gt; 50]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This conciseness and clarity of Python make us very productive as developers while our code is still easily readable and clear to others.&lt;/p&gt;
&lt;h2 id="multi-paradigm"&gt;Multi paradigm&lt;a class="headerlink" href="#multi-paradigm" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In Python, we can choose which programming paradigm we want to use for our program. &lt;/p&gt;
&lt;p&gt;You can write programs in the traditional &lt;a href="https://en.wikipedia.org/wiki/Imperative_programming"&gt;imperative&lt;/a&gt; (&lt;a href="https://en.wikipedia.org/wiki/Procedural_programming"&gt;procedural&lt;/a&gt;) programming style, where the computer executes a series of statements in order.&lt;/p&gt;
&lt;p&gt;Python also supports an &lt;a href="https://en.wikipedia.org/wiki/Object-oriented_programming"&gt;Object-oriented programming&lt;/a&gt; paradigm where we create hierarchies of classes with methods. It supports polymorphism, inheritance (including multiple inheritance) and other OOP concepts.&lt;/p&gt;
&lt;p&gt;Last but not least, Python has excellent support for functional programming. &lt;br&gt;
All functions in Python are &lt;a href="https://en.wikipedia.org/wiki/First-class_function"&gt;first-class functions&lt;/a&gt;. They can be passed around and manipulated like any other object. This feature allows &lt;a href="https://en.wikipedia.org/wiki/Higher-order_function"&gt;higher-order functions&lt;/a&gt; like map, filter and reduce. It has comprehensions and generator expressions. Many other functions to support functional programming are in &lt;em&gt;itertools&lt;/em&gt; and &lt;em&gt;functools&lt;/em&gt; modules.&lt;/p&gt;
&lt;h2 id="versatile"&gt;Versatile&lt;a class="headerlink" href="#versatile" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We can do pretty much anything in Python. &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;simple scripts to automate some trivial tasks&lt;/li&gt;
&lt;li&gt;websites with millions of users&lt;/li&gt;
&lt;li&gt;heavy data processing backends&lt;/li&gt;
&lt;li&gt;APIs&lt;/li&gt;
&lt;li&gt;desktop apps&lt;/li&gt;
&lt;li&gt;software for IoT (Internet of Things, think RaspberryPi, Arduino etc.)&lt;/li&gt;
&lt;li&gt;data visualisation&lt;/li&gt;
&lt;li&gt;ML&lt;/li&gt;
&lt;li&gt;and so much more&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That is why many major companies (Amazon, Google, Netflix, 
Instagram, Dropbox, Spotify, NASA and so on) and millions of small companies and independent developers worldwide use Python.&lt;/p&gt;
&lt;h2 id="runs-almost-everywhere"&gt;Runs almost everywhere&lt;a class="headerlink" href="#runs-almost-everywhere" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python runs on most of the relevant platforms today. It runs on x86, x86_64 and ARM. It also runs on all major operating systems of today - Linux, Windows, macOS and even FreeBSD.&lt;/p&gt;
&lt;p&gt;We can write our code anywhere, and we can run it anywhere.&lt;/p&gt;
&lt;h2 id="community-and-libraries"&gt;Community and libraries&lt;a class="headerlink" href="#community-and-libraries" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python is an open-source, independent and community-driven language. It has a vast community of developers and enthusiasts. They're very supportive and friendly, which benefits both new and expert developers. &lt;/p&gt;
&lt;p&gt;Community is dedicated to maintaining and spreading the language, so there are hundreds of thousands of libraries to help us with whatever we need to do.&lt;/p&gt;
&lt;p&gt;Frameworks like Django and Flask (for web development), Numpy, Panda, NLTK, PyTorch (for ML and data science) and thousands of libraries for almost anything we can think of are free to use and open-source.&lt;/p&gt;
&lt;p&gt;Thousands of Python developers are willing to help us if we ask.&lt;/p&gt;
&lt;h2 id="machine-learning-and-data-science"&gt;Machine Learning and Data science&lt;a class="headerlink" href="#machine-learning-and-data-science" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Machine learning and data science have been rising over the last few years and will continue to grow in the coming years. &lt;/p&gt;
&lt;p&gt;We can use any language for ML and data-science related tasks, but Python has become a preferred language for this domain. Most companies and most of the tutorials and courses use Python as the language of choice for the ML domain.&lt;/p&gt;
&lt;p&gt;It's thanks to Python's strengths which we mentioned already above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syntax and conciseness - which makes developers very productive and allows even beginners to write good code&lt;/li&gt;
&lt;li&gt;exhaustive libraries which give us solutions to all existing problems&lt;/li&gt;
&lt;li&gt;community build around the whole ML domain&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, for anyone interested in Machine learning, Python is the language that will help them succeed.&lt;/p&gt;
&lt;h2 id="gradual-typing"&gt;Gradual typing&lt;a class="headerlink" href="#gradual-typing" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python is a dynamic language. &lt;/p&gt;
&lt;p&gt;It has its advantages and disadvantages, which I don't want to discuss here in detail, but it means we can write code without worrying about types and the compiler checking them. &lt;/p&gt;
&lt;p&gt;It's great if we need to write a little script to automate something, 
or we want to build a prototype of the idea, or we're working on a smaller project with few people.&lt;/p&gt;
&lt;p&gt;However, for bigger projects with more developers,  types are beneficial as they help us write more robust code, and we can catch more errors before we run the code. &lt;/p&gt;
&lt;p&gt;It would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;from typing import List

def function_a(a: int, b: List[str]):
    pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above function, parameter &lt;code&gt;a&lt;/code&gt; has to be of type &lt;code&gt;int&lt;/code&gt;, and parameter &lt;code&gt;b&lt;/code&gt; must be a list of strings - &lt;code&gt;List[str]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The beauty of Python is that we can have both. We can write our code without types, but we can also add type annotations if we want to. &lt;/p&gt;
&lt;p&gt;Then we can use a static type checker like &lt;a href="http://mypy-lang.org"&gt;mypy&lt;/a&gt; to do the type checking to help us catch any possible errors. 
We can choose to use types from the beginning of the project (or after we've built MVP), or we can start our project without types and introduce them much later when our codebase and number of developers grow.&lt;/p&gt;
&lt;h2 id="career"&gt;Career&lt;a class="headerlink" href="#career" title="Permanent link"&gt;Permalink&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python has been around for over 30 years, and over time it's only growing in popularity. Startups, small and medium companies, and big enterprises alike are using it to create their software. &lt;/p&gt;
&lt;p&gt;Its popularity creates a constant demand for Python programmers all over the world. &lt;/p&gt;
&lt;p&gt;And Python jobs come with high salaries.&lt;/p&gt;
&lt;p&gt;Python will serve you well, whether you want to build a career as an employee, or you want to be an independent developer or build your own business.&lt;/p&gt;</content><category term="Python explained"></category><category term="python"></category></entry></feed>